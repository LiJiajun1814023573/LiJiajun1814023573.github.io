{"meta":{"title":"青山入我怀","subtitle":null,"description":"尔入我梦来","author":"LiJiajun","url":""},"pages":[{"title":"about","date":"2018-12-12T14:14:36.000Z","updated":"2020-03-16T10:41:30.000Z","comments":false,"path":"about/index.html","permalink":"/about/index.html","excerpt":"","text":"[さくら荘のhojun] 与&nbsp; Mashiro&nbsp; （ 真（ま）白（しろ） ） 对话中... bot_ui_ini()","keywords":"关于"},{"title":"bangumi","date":"2019-02-10T13:32:48.000Z","updated":"2020-03-16T10:41:30.000Z","comments":false,"path":"bangumi/index.html","permalink":"/bangumi/index.html","excerpt":"","text":"","keywords":null},{"title":"client","date":"2018-12-20T15:13:35.000Z","updated":"2020-03-16T10:41:30.000Z","comments":false,"path":"client/index.html","permalink":"/client/index.html","excerpt":"","text":"直接下载 or 扫码下载：","keywords":"Android客户端"},{"title":"categories","date":"2020-07-03T01:45:35.000Z","updated":"2020-07-03T01:46:24.359Z","comments":true,"path":"categories/index.html","permalink":"/categories/index.html","excerpt":"","text":""},{"title":"donate","date":"2018-12-20T15:13:05.000Z","updated":"2020-03-16T10:41:30.000Z","comments":false,"path":"donate/index.html","permalink":"/donate/index.html","excerpt":"","text":"","keywords":"谢谢饲主了喵~"},{"title":"comment","date":"2018-12-20T15:13:48.000Z","updated":"2020-03-16T10:41:30.000Z","comments":true,"path":"comment/index.html","permalink":"/comment/index.html","excerpt":"","text":"念两句诗 叙别梦、扬州一觉。 【宋代】吴文英《夜游宫·人去西楼雁杳》","keywords":"留言板"},{"title":"links","date":"2018-12-19T15:11:06.000Z","updated":"2020-03-16T10:41:30.000Z","comments":true,"path":"links/index.html","permalink":"/links/index.html","excerpt":"","text":"","keywords":"友人帐"},{"title":"lab","date":"2019-01-05T13:47:59.000Z","updated":"2020-03-16T10:41:30.000Z","comments":false,"path":"lab/index.html","permalink":"/lab/index.html","excerpt":"","text":"sakura主题balabala","keywords":"Lab实验室"},{"title":"music","date":"2018-12-20T15:14:28.000Z","updated":"2020-07-03T11:47:24.478Z","comments":false,"path":"music/index.html","permalink":"/music/index.html","excerpt":"","text":"","keywords":"喜欢的音乐"},{"title":"rss","date":"2018-12-20T15:09:03.000Z","updated":"2020-03-16T10:41:30.000Z","comments":true,"path":"rss/index.html","permalink":"/rss/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-12-12T14:14:16.000Z","updated":"2020-03-16T10:41:30.000Z","comments":true,"path":"tags/index.html","permalink":"/tags/index.html","excerpt":"","text":""},{"title":"theme-sakura","date":"2019-01-04T14:53:25.000Z","updated":"2020-03-16T10:41:30.000Z","comments":false,"path":"theme-sakura/index.html","permalink":"/theme-sakura/index.html","excerpt":"","text":"Hexo主题Sakura修改自WordPress主题Sakura，感谢原作者Mashiro","keywords":"Hexo 主题 Sakura 🌸"},{"title":"video","date":"2018-12-20T15:14:38.000Z","updated":"2020-03-16T10:41:30.000Z","comments":false,"path":"video/index.html","permalink":"/video/index.html","excerpt":"","text":"var videos = [ { img: 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '放送时间: 2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' }, { img : 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' } ] .should-ellipsis{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:95%;}.should-ellipsis-full{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:100%;}.should-ellipsis i{position:absolute;right:24px;}.grey-text{color:#9e9e9e !important}.grey-text.text-darken-4{color:#212121 !important}html{line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}img{border-style:none}progress{display:inline-block;vertical-align:baseline}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}html{-webkit-box-sizing:border-box;box-sizing:border-box}*,*:before,*:after{-webkit-box-sizing:inherit;box-sizing:inherit}ul:not(.browser-default){padding-left:0;list-style-type:none}ul:not(.browser-default)>li{list-style-type:none}.card{-webkit-box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2);box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2)}.hoverable{-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s}.hoverable:hover{-webkit-box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19);box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19)}i{line-height:inherit}i.right{float:right;margin-left:15px}.bangumi .right{float:right !important}.material-icons{text-rendering:optimizeLegibility;-webkit-font-feature-settings:'liga';-moz-font-feature-settings:'liga';font-feature-settings:'liga'}.row{margin-left:auto;margin-right:auto;margin-bottom:20px}.row:after{content:\"\";display:table;clear:both}.row .col{float:left;-webkit-box-sizing:border-box;box-sizing:border-box;padding:0 .75rem;min-height:1px}.row .col.s12{width:100%;margin-left:auto;left:auto;right:auto}@media only screen and (min-width:601px){.row .col.m6{width:50%;margin-left:auto;left:auto;right:auto}}html{line-height:1.5;font-family:-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,Oxygen-Sans,Ubuntu,Cantarell,\"Helvetica Neue\",sans-serif;font-weight:normal;color:rgba(0,0,0,0.87)}@media only screen and (min-width:0){html{font-size:14px}}@media only screen and (min-width:992px){html{font-size:14.5px}}@media only screen and (min-width:1200px){html{font-size:15px}}.card{position:relative;margin:.5rem 0 1rem 0;background-color:#fff;-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s;border-radius:2px}.card .card-title{font-size:24px;font-weight:300}.card .card-title.activator{cursor:pointer}.card .card-image{position:relative}.card .card-image img{display:block;border-radius:2px 2px 0 0;position:relative;left:0;right:0;top:0;bottom:0;width:100%}.card .card-content{padding:24px;border-radius:0 0 2px 2px}.card .card-content p{margin:0}.card .card-content .card-title{display:block;line-height:32px;margin-bottom:8px}.card .card-content .card-title i{line-height:32px}.card .card-reveal{padding:24px;position:absolute;background-color:#fff;width:100%;overflow-y:auto;left:0;top:100%;height:100%;z-index:3;display:none}.card .card-reveal .card-title{cursor:pointer;display:block}.waves-effect{position:relative;cursor:pointer;display:inline-block;overflow:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;vertical-align:middle;z-index:1;-webkit-transition:.3s ease-out;transition:.3s ease-out}.waves-effect img{position:relative;z-index:-1}.waves-block{display:block}::-webkit-input-placeholder{color:#d1d1d1}::-moz-placeholder{color:#d1d1d1}:-ms-input-placeholder{color:#d1d1d1}::-ms-input-placeholder{color:#d1d1d1}[type=\"radio\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"radio\"]:not(:checked)+span{position:relative;padding-left:35px;cursor:pointer;display:inline-block;height:25px;line-height:25px;font-size:1rem;-webkit-transition:.28s ease;transition:.28s ease;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border-radius:50%}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border:2px solid #5a5a5a}[type=\"radio\"]:not(:checked)+span:after{-webkit-transform:scale(0);transform:scale(0)}[type=\"checkbox\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"checkbox\"]:not(:checked):disabled+span:not(.lever):before{border:none;background-color:rgba(0,0,0,0.42)}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):before{width:0;height:0;border:3px solid transparent;left:6px;top:10px;-webkit-transform:rotateZ(37deg);transform:rotateZ(37deg);-webkit-transform-origin:100% 100%;transform-origin:100% 100%}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):after{height:20px;width:20px;background-color:transparent;border:2px solid #5a5a5a;top:0px;z-index:0}input[type=checkbox]:not(:disabled) ~ .lever:active:before,input[type=checkbox]:not(:disabled).tabbed:focus ~ .lever::before{-webkit-transform:scale(2.4);transform:scale(2.4);background-color:rgba(0,0,0,0.08)}input[type=range].focused:focus:not(.active)::-webkit-slider-thumb{-webkit-box-shadow:0 0 0 10px rgba(38,166,154,0.26);box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-moz-range-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-ms-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)} 番组计划 这里将是永远的回忆 window.onload = function(){ videos.forEach(function(video, i){ $('#rootRow').append(` ${video.title} ${video.jp} ${video.status} ${video.title} ${video.jp} 放送时间: ${video.time} ${video.desc} ${video.status} `) }) }","keywords":"B站"}],"posts":[{"title":"ES6重难点细解","slug":"ES6重难点细解","date":"2020-07-29T11:46:57.418Z","updated":"2020-07-29T13:09:46.403Z","comments":true,"path":"2020/07/29/ES6重难点细解/","link":"","permalink":"/2020/07/29/ES6重难点细解/","excerpt":"","text":"ES6重难点细解解构赋值核心点&nbsp;&nbsp;详细请看掘金上的这篇文章ES6系列解构赋值全解析&nbsp;&nbsp; 解构赋值的出现避免了赋值过程中循环的嵌套与复杂代码的产生． 对象的解构赋值 与对象属性同名的变量能够被成功赋值，如： let details = { firstName:&#39;Code&#39;, lastName:&#39;Burst&#39;, age:22 } const {firstName,age} = details; console.log(firstName); // Code console.log(age); // 22 不同名的变量通过映射赋值，通过冒号映射，如： const person = { name: &#39;jsPool&#39;, country: &#39;China&#39; }; const {name:fullname,country:place} = person; console.log(fullname); // jsPool console.log(place); // China 默认值，应用于当属性不存在时，可以用=指定一个默认值* 嵌套对象与此相似． 数组的解构赋值 解构索引对应的值，用变量按顺序接收，因此可用”,”号占位省略元素．如 let list = [221,&#39;Baker Street&#39;,&#39;London&#39;]; let [houseNo,,city] = list; console.log(houseNo,city);// 221 , London 不定元素let colors = [&#39;red&#39;,&#39;green&#39;,&#39;blue&#39;]; let [firstColor,...otherColors] = colors; console.log(firstColor); // red console.log(otherColors); // [&#39;green&#39;,&#39;blue&#39;] 解构赋值的应用场合： 交换变量值：[x, y] = [y, x] 返回函数多个值：const [x, y, z] = Func() 定义函数参数默认值：function Func({ x = 1, y = 2 } = {}) {} 定义函数参数：Func([1, 2]),在调用时会将1,2传递给[x,y]中的x和y． 提取JSON数据：const { name, version } = packageJson 遍历Map结构：for (let [k, v] of Map) {} 输入模块指定属性和方法：const { readFile, writeFile } = require(“fs”) 函数拓展 可为参数设置默认值，且设置之后，函数进行声明初始化时，参数会形成一个单独的context,作用域在初始化结束后消失,如:`var x = 1; function f(x, y = x) { console.log(y);}f(2) // 2 调用函数f时，参数形成单独的作用域，在此作用域中，默认变量x指向第一个参数x而不是全局变量x let x = 1; function f( y = x ) { let x = 2; console.log(y);}f() // 1 在y=x形成的作用域中，变量x没有定义因此指向外层变量x，调用时，函数体内部的局部变量x无法影响默认值变量x． * tips:可用延展运算符作为函数参数接受多个值 * 箭头函数: * 箭头函数如果返回一个对象，则在外面加一个括号． * 由箭头函数这引申出的this指向问题，可看掘金的这篇文章[js的this指来指去到底指向哪](https://juejin.im/post/5cbda5266fb9a03214376078) * 注意setTimeout执行环境是window,因为是window.setTimeout * 普通function调用与new构造函数function创建出来的实例对象this指向不同．所以非实例化(new)调用function，this都指向window * 对象中创建的函数中的this始终指向最后一个调用它的对象 * 闭包中的this指向，闭包函数具有匿名函数自执行的特性，默认this指向是挂在window下的 * 箭头函数中的this为定义时绑定，就是绑定最近一层非箭头函数的this，对象中箭头函数this指向window且无法改变 * 多层对象嵌套里箭头函数的this和最外层保持一致． const obj = { a: function() { console.log(this) }, b: { c: () =&gt; {console.log(this)} } } obj.a() //没有使用箭头函数打出的是obj obj.b.c() //打出的是window对象！！ ```． 对象拓展与Map,Symbol,Set数组与对象拓展以及 Symbol,Set和Map Symbol常用在为对象取独一无二的属性名时 直接Symbol()调用，接受字符串为描述，Symbol值能转为布尔值 Symbol作为对象时不能用.运算符，因为.运算符的后面必须是一个字符串，因此用obj[s] 属性名不能被常规方法遍历得到，即不能出现在for…in,for…of循环中，Object.keys(),Object.getOwnPropertyNames()得到，可以用getOwnPropertySymbols得到所有的属性名． Symbol.for查询，返回一个Symbol值，没有则新建． Symbol.keyFor返回一个已登记的Symbol类型值的key．Symbol.for为Symbol登记的名字是全局环境的．* Set类似于数组，但成员值都是唯一的．可直接用于数组去重[…new Set(array)] 常见方法有add,delete,has,clear* Set实例有四个遍历方法,keys,values,entries,forEach同Map Map类似于对象，是键值对的集合，但是键的范围很大，包括对象都可以是键． 常见方法有：set(key,val),get,delete,has,clear js的四种for循环掘金上的这篇文章讲解的非常到位：js的四种for循环","categories":[{"name":"Web前端","slug":"Web前端","permalink":"/categories/Web前端/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"/tags/javascript/"}],"keywords":[{"name":"Web前端","slug":"Web前端","permalink":"/categories/Web前端/"}]},{"title":"egret游戏开发","slug":"egret游戏开发","date":"2020-07-16T02:30:04.499Z","updated":"2020-07-16T02:36:08.761Z","comments":true,"path":"2020/07/16/egret游戏开发/","link":"","permalink":"/2020/07/16/egret游戏开发/","excerpt":"","text":"引言游戏目前阶段有以下需求： 制作英雄图demo与相关动作特效 探究实现遮罩与碰撞检测 缓动过程的事件处理 探究子弹类的处理 探究寻路算法 结合egret的h5游戏开发指南，以及基础知识的补充，可以对这些问题有具象化的认识，而不是无从下手，因此对核心内容进行自己的一些总结，部分摘自指南，部分是尝试过程中的结论。 游戏基础显示对象 显示对象是能参与渲染的对象的抽象表示 需要了解的是DisplayObject类是显示对象基类。 Sprite类，是用来绘制矢量图形/充当容器。 Bitmap显示位图 MovieClip类，也是继承自显示对象类，因此我们可以通过该类制作帧动画，并拥有显示对象类的所有方法后面会给出例子。 Shape类，用来绘制矢量图形 …. 显示列表：显示对象加入显示列表中才能被渲染 常见的:addChild就是让显示对象加入显示列表，而addChild的调用者是显示容器，也就是说只有显示容器可以调用，且其可以嵌套。 DisplayObject与DisplayObjectContainer的关系 DisplayObjectContainer继承自DisplayObject类，因此显示容器也具有显示对象的属性和方法。Sprite是显示容器，Shape是显示对象。也正是因为显示对象容器继承自显示对象，addChild也可以作用于容器。 Shape类绘制矢量图在我们的项目中使用不多暂不多解释，有需求再去查api文档即可。 必要时可创建容器，集成一些相联的显示对象组件，进行处理，增删显示对象 在显示列表删除显示对象，即结束显示对象的渲染，如this.addChild(#一个帧动画#)，帧动画可以使用stop方法停止，如果想结束其渲染，可以使用this.removeChild。可见显示对象独立于显示列表也就是说removeChild之后需要在内存中删除才算彻底销毁。 显示对象只能加入到一个显示列表中 显示对象设置的x,y坐标属性是相对坐标系，其中显示对象具体位置也与锚点有关(后续会有相关运用) 遮罩与碰撞 显示对象都具备遮罩功能 使用egret.Rectangle(firstx,firsty,lastx,lasty)创建一块矩形区域rect， 然后设置obj.mask = rect.即设置了遮罩。 obj.mask=null取消。 碰撞检测 非精确碰撞检测 显示对象的方法，hitTestPoint,检测是否与指定点相交，目前来说意义不大。 精确碰撞检测 hitTestPoint方法增加一个参数，true开启精确碰撞检测，消耗更多资源，是基于像素的检测而不是包围盒。 包围盒检测 文档中没有提到这个，但是指南中给出了，思路是利用两个包围盒，即利用egret.Rectangle确定两个矩形区域，然后利用Rectangle类中的方法inersects，rect1.intersects(rect2)来判断是否相交。 动画 对于动画，egret提供多种处理，如逐帧动画，或是tween库实现缓动动画 逐帧动画 素材制作 采用gif图片转换的方式。可以生成逐帧动画图片和逐帧动画数据，利用的工具是Texture Merger,导出最终文件包含两个一个是描述动画的配置文件.json,一个是图片纹理集。 素材引入 egretProperties.json配置文件需要增加game库，原因是这个动画帧类是来自game库的 default.res.json配置文件加入导入的json文件和纹理集图片。 创建逐帧动画 MovieClip中的MovieClipData是存储逐帧动画数据，而MovieClipDataFactory是用来存储MoiveClipData和Texture,存储数据和纹理的。 MovieClip功能的简化，使得只保留和动画相关的逻辑，而数据，纹理相关的操作与其分离。 MovieClip的使用： 先使用RES.getRes()获得资源（数据和纹理集） 然后new egret.MovieClipDataFactory(data,tex)得到一个movieClipDataFactory new egret.MovieClip(mcf.generateMovieClipData(“mcName(json文件中找到)”)) 即可创建一个MovieClip.包含json也包含纹理集，而json文件中可以得到不同帧资源名。刚创建的时候只能得到第一帧资源，所以mcf.spriteSheet.getTexture(“第一帧资源名”)，这个似乎不是很重要. 其它的例如停止动画，跳转动画，动画缓存的api都可以用到时再查阅了解。 还可以给帧图片添加事件。这个我没有试过不过应该很有意义。 tween缓动动画 egret.Tween.get定义缓动 第二个参数，可以加入变化事件处理函数的定义来实现逻辑的实时变化 如var obj = {x:0}; var funcChange = function():void{ console.log(this.x); } egret.Tween.get(obj,{onChange:funcChange,onChangeObj:obj}).to({x:600},1000,egret.Ease.backInOut); 缓动对象的控制有一些方法 主要有两种如call，用于缓动后的回调 如wait用于指定多个缓动连续设定中设置中间等待时间 应用解决针对以下需求： 制作英雄图demo与相关动作特效 探究实现遮罩与碰撞检测 缓动过程的事件处理 探究子弹类的处理 探究寻路算法 (待完成) 1 制作英雄图demo与相关动作特效 截取素材，利用工具制作gif,利用Texture Merger导出再应用到egret项目中。 在main.ts测试在createGameScene方法中 var data = RES.getRes(&quot;test_json&quot;); var txtr = RES.getRes(&quot;test_png&quot;); var mcFactory:egret.MovieClipDataFactory = new egret.MovieClipDataFactory( data, txtr ); var mc1:egret.MovieClip = new egret.MovieClip(mcFactory.generateMovieClipData(&quot;1&quot;)); this.addChild(mc1); this.stage.frameRate = 60; mc1.addEventListener(egret.Event.ENTER_FRAME,this.move,mc1); mc1.anchorOffsetX = 53; mc1.anchorOffsetY = 58.5; mc1.x = 53; mc1.y = 58.5; mc1.gotoAndPlay(1,-1); 首先我们关注这一部分：这是用来创建动画帧，然后加入到舞台的 var data = RES.getRes(&quot;test_json&quot;); var txtr = RES.getRes(&quot;test_png&quot;); var mcFactory:egret.MovieClipDataFactory = new egret.MovieClipDataFactory( data, txtr ); var mc1:egret.MovieClip = new egret.MovieClip(mcFactory.generateMovieClipData(&quot;1&quot;)); this.addChild(mc1); 在播放之前，我们写了监听，每一帧改变图片的坐标，使得图片运动起来，这样使得动画也可以运动起来，move方法等会解释。 mc1.addEventListener(egret.Event.ENTER_FRAME,this.move,mc1); 这里设置锚点为动画图片的一半宽一半高，因为没有anchorX和anchorY方法(这个可以直接设置相对比例0.5).关于锚点在了解后，如果我们想图片从原点开始需要设置x,y坐标为宽高的一半，因为是以锚点为基准进行定位了。 mc1.anchorOffsetX = 53; mc1.anchorOffsetY = 58.5; mc1.x = 53; mc1.y = 58.5; mc1.gotoAndPlay(1,-1); move方法，之所以设置锚点，是为了图片进行旋转，否则会出现bug，即旋转之后又x坐标减小，同时为了模拟碰撞，做了一个测试，即当检测到300,40的点时，改变角度，同时更改行动方式。这里就没有针对不同角度给出不同的动画了，对于一个小游戏可能过于繁琐，而是采用图片旋转的方式，不过看上去有点别扭。 private move(evt:egret.Event){ if(this.hitTestPoint(300,40)){ this.rotation = 90; this.y = this.y + 1; }else{ this.rotation = 0; this.x = this.x + 1; } } 2 碰撞检测 如果有碰撞检测的需求，可以结合上面提到的两个包围盒方法进行针对性解决. 由于可显示对象都是图片，有宽高，有x,y坐标，因此包围盒的方法还是有效的。 但是图片中人物的占空间和其它实际因素可能会影响，根据需求选择。 3 缓动过程的事件处理 如果是动画的事件处理，如对于死亡事件，我们可以直接stop动画，然后从父容器中remove，随后delete帧动画。 这样可以解决动画结束之前死亡的问题，至于何时攻击有效，可能得经过调试，也可以做的模糊一些。 如果是缓动过程需要有事件处理，如子弹的缓动过程碰到目标之前遇到其它敌方英雄，缓动提前结束，这是一个事件处理，这里可以直接获取tween对象，使用缓动结束方法，使用改方法的条件，可以采用碰撞检测的方式，即子弹与目标进行碰撞就终止缓动，可以把子弹当作一个点，或是矩形，这是后面具体处理方式的不同。 4 子弹的处理 方便的方式即是采用缓动，并且使用tween.to来进行子弹移动. 其实把子弹的移动速度提高，3中提到的子弹缓动过程的事件处理是不需要的，因为只要确定tween.to的目标几乎总能击中目标。","categories":[{"name":"Web前端","slug":"Web前端","permalink":"/categories/Web前端/"},{"name":"游戏","slug":"Web前端/游戏","permalink":"/categories/Web前端/游戏/"}],"tags":[{"name":"egret","slug":"egret","permalink":"/tags/egret/"}],"keywords":[{"name":"Web前端","slug":"Web前端","permalink":"/categories/Web前端/"},{"name":"游戏","slug":"Web前端/游戏","permalink":"/categories/Web前端/游戏/"}]},{"title":"webGL入门(一)","slug":"WebGL入门(一)","date":"2020-07-03T00:59:35.637Z","updated":"2020-07-16T02:33:29.271Z","comments":true,"path":"2020/07/03/WebGL入门(一)/","link":"","permalink":"/2020/07/03/WebGL入门(一)/","excerpt":"","text":"WebGL介绍产生背景 WebGL出现之前，浏览器想要实现3d效果必须借助浏览器插件，如Adobe的flash，微软的silverLight等等 WebGL 是一组基于 JavaScript 语言的图形规范，浏览器厂商按照这组规范进行实现，为 Web 开发者提供一套3D图形相关的 API 这套api，使得开发者能够使用javscript语言与gpu进行通信．而webGL的gpu部分也有对应的编程语言简称GLSL,GLSL程序即为运行在gpu上的着色器程序．着色器程序接受cpu传递过来的数据（webgl使用js），然后对数据进行流水线处理，就可以显示在屏幕上从而实现各种3d应用．工作方式 WebGL的工作方式与流水线相似．从得到数据到渲染到屏幕上，流水线按照既定的步骤从原料到加工，每一步的处理的原材料是上一步加工得到的结果，加工最终形成完整的产品．这种渲染方式我们称之为图形管线/渲染管线 WebGL的图元是点，线段，三角形三种图元，而对于其它的webGL程序中出现的图形甚至一些逼真的不规则模型，都是由gpu将点用三角形图元绘制，并且由三角形平面拼接而成得到的． 传递给gpu的顶点数据和变换矩阵数据，顶点经过转换之后的坐标是webGL接受的坐标，即gpu渲染管线对这些数据进行流水线作业．gpu渲染管线作用过程 首先进入顶点着色器阶段，利用 GPU 的并行计算优势对顶点逐个进行坐标变换。 然后进入图元装配阶段，将顶点按照图元类型组装成图形。 接下来来到光栅化阶段，光栅化阶段将图形用不包含颜色信息的像素填充。 在之后进入片元着色器阶段，该阶段为像素着色，并最终显示在屏幕上。 GLSL GLSL是OpenGL Shading Language缩写，即openGL的着色器语言 着色器语言指的是运行在gpu上的剪短程序，代替了gpu固定渲染管线的一部分，使得gpu渲染程序能够通过编程控制. GLSL控制gpu渲染管线的部分: 顶点着色器 片元着色器 开发者可通过编程控制gpu渲染管线的部分: js程序，传递顶点数据，法向量，纹理，颜色等等 顶点着色器 片元着色器 关于顶点信息的变换： 在js中进行，即通过js代码将通过变换矩阵转换好的顶点信息传递给gpu 在js中将变换矩阵传递给着色器程序，由顶点着色器程序实现对顶点信息的转换． 本篇文章是对WebGL的整体简介，是WebGL入门的第一篇文章，后续会对WebGL编程的学习进行完整的记录．","categories":[{"name":"Web前端","slug":"Web前端","permalink":"/categories/Web前端/"}],"tags":[{"name":"WebGL","slug":"WebGL","permalink":"/tags/WebGL/"}],"keywords":[{"name":"Web前端","slug":"Web前端","permalink":"/categories/Web前端/"}]},{"title":"flutter系列之dart事件循环","slug":"dart事件循环","date":"2020-07-01T14:23:29.026Z","updated":"2020-07-03T12:43:47.311Z","comments":true,"path":"2020/07/01/dart事件循环/","link":"","permalink":"/2020/07/01/dart事件循环/","excerpt":"上一篇介绍了dart基础．这一篇将讲述flutter代码的执行和运行的机制． Dart单线程类比js．js单线程关键点在于主线程，微任务与宏任务． 主线程－主业务逻辑 异步，网络I/O,本地文件I/O,采用事件驱动执行 dart中单线程执行，其中包含两个事件队列，一个是微任务事件队列，一个是事件队列(对应于js的宏任务) 微任务队列：scheduleMicrotask调度 事件队列: 包含外部事件，如I/O,Timer,绘制事件等等 事件循环过程对于js的事件循环之前有出过一篇文章，此处再贴一篇讲的很不错的js事件循环的文章，有助于对其加深理解．从一道题浅说JavaScript的事件循环而对于dart，刚才介绍了dart单线程相关的核心内容，在掌握了js的事件循环后，类比到dart上也十分容易． 1).执行main函数，产生微任务和事件任务队列2).判断是否存在微任务，有则执行，执行完后再判断是否还存在微任务，没则判断是否存在事件任务（即每当一个任务执行完成后，微任务会执行到微任务队列清空再去看事件队列是否有任务)3).如果有事件任务，执行完后再判断是否还有微任务，如果有先执行微任务．如24).在微任务和宏任务执行时，也会产生新的微任务和事件任务．","text":"上一篇介绍了dart基础．这一篇将讲述flutter代码的执行和运行的机制． Dart单线程类比js．js单线程关键点在于主线程，微任务与宏任务． 主线程－主业务逻辑 异步，网络I/O,本地文件I/O,采用事件驱动执行 dart中单线程执行，其中包含两个事件队列，一个是微任务事件队列，一个是事件队列(对应于js的宏任务) 微任务队列：scheduleMicrotask调度 事件队列: 包含外部事件，如I/O,Timer,绘制事件等等 事件循环过程对于js的事件循环之前有出过一篇文章，此处再贴一篇讲的很不错的js事件循环的文章，有助于对其加深理解．从一道题浅说JavaScript的事件循环而对于dart，刚才介绍了dart单线程相关的核心内容，在掌握了js的事件循环后，类比到dart上也十分容易． 1).执行main函数，产生微任务和事件任务队列2).判断是否存在微任务，有则执行，执行完后再判断是否还存在微任务，没则判断是否存在事件任务（即每当一个任务执行完成后，微任务会执行到微任务队列清空再去看事件队列是否有任务)3).如果有事件任务，执行完后再判断是否还有微任务，如果有先执行微任务．如24).在微任务和宏任务执行时，也会产生新的微任务和事件任务．来看两道常见的例题例1. import &#39;dart:async&#39;; void main() { print(&#39;flow start&#39;); // 执行打印开始 // 执行判断为事件任务，添加到事件任务队列 Timer.run((){ print(&#39;event&#39;); // 执行事件任务，打印标记 }); // 执行判断为微任务，添加到微任务队列 scheduleMicrotask((){ print(&#39;microtask&#39;); // 执行微任务，打印标记 }); print(&#39;flow end&#39;); // 打印结束标记 } 结果是 flow start flow end microtask event 分析过程：1).首先执行main函数中的代码，打印flow start2).Timer为事件任务，放入事件队列，scheduleMicrotask为微任务，放入微任务队列，同时向下执行代码打印flow end3).先从微任务队列中取出微任务执行，因此打印microtask4).微任务队列为空，则从事件任务队列中取出事件任务执行，打印event例2. import &#39;dart:async&#39;; void main() { print(&#39;flow start&#39;); // 执行打印开始 // 执行判断为事件任务，添加到事件任务队列 Timer.run((){ print(&#39;event&#39;); // 执行事件任务，打印事件任务记 // 执行判断为微任务，添加到微任务队列 scheduleMicrotask((){ print(&#39;microtask in event&#39;); // 执行微任务，打印微任务标记 }); }); // 执行判断为微任务，添加到微任务队列 scheduleMicrotask((){ print(&#39;microtask&#39;); // 执行微任务，打印微任务执行标记 // 执行判断为事件任务，添加到事件任务队列 Timer.run((){ print(&#39;event in microtask&#39;); // 执行事件任务，打印事件任务标记 }); }); print(&#39;flow end&#39;); // 打印结束标记 } 结果 flow start flow end microtask event microtask in event event in microtask 分析过程：1).main函数中代码先执行打印flow start2).Timer,为事件任务，放入事件任务队列．3).代码向下执行，scheduleMicrotask为微任务，放入微任务队列4).继续向下执行，打印flow end5).此时，微任务队列中有任务，因此执行scheduleMicrotask中代码，先print microtask,然后Timer放入事件任务队列6).微任务队列为空，因此去事件任务队列取出最先放入队列中的事件任务．打印event,向下遇到scheduleMicrotask，放入微任务队列．7).事件任务执行完毕后，由于微任务队列中有任务，所以执行微任务．因此先打印microtask in event．8).最后执行事件任务队列中的打印event in microtask 引发出的一个问题 dart在运行过程中可能被事件运行卡住 可想而知的是，当事件任务执行时，如果进行了密集计算，其中等待事件任务执行结束的时间就会增长． 而从事件循环．我们知道如果当前事件任务没有执行结束，是无法进行下一轮循环的．因此整个dart运行就会被卡住． 因此避免由于事件密集计算而导致较差的用户体验． 关于dart多线程内容，我们放在下一篇博客中介绍，届时我们会对dart运行原理大概有一个整体的掌握．然后就会进入flutter的学习之中．","categories":[{"name":"Web前端","slug":"Web前端","permalink":"/categories/Web前端/"}],"tags":[{"name":"dart","slug":"dart","permalink":"/tags/dart/"},{"name":"flutter","slug":"flutter","permalink":"/tags/flutter/"},{"name":"事件循环","slug":"事件循环","permalink":"/tags/事件循环/"}],"keywords":[{"name":"Web前端","slug":"Web前端","permalink":"/categories/Web前端/"}]},{"title":"flutter系列之dart基础","slug":"dart基础(一)","date":"2020-06-29T14:08:11.019Z","updated":"2020-07-03T11:37:55.950Z","comments":true,"path":"2020/06/29/dart基础(一)/","link":"","permalink":"/2020/06/29/dart基础(一)/","excerpt":"由于近期有学习flutter的兴趣，因此首先学习其所需的编程语言dart.并采用dart与js对比差异的方式来进行学习． 基础数据类型 Number和String与js使用基本一致 Symbol的区别 js中，Symbol是将基础数据类型转换为唯一标识符，核心应用是将复杂引用数据类型转换为对象数据类型的键名．具体可参考js中Symbol,map,set 在 Dart 中，Symbol 是不透明的动态字符串名称，用于反映库中的元数据。用 Symbol 可以获得或引用类的一个镜像，概念比较复杂，但其实和 JavaScript 的用法基本上是一致的。例如，下面代码首先 new 了一个 test 为 Map 数据类型，设置一个属性 #t（Symbol 类型），然后分别打印 test、test 的 #t、test 的 Symbol(“t”) 和 #t。 void main() { Map test = new Map(); test[#t] = &#39;symbol test&#39;; print(test); print(test[#t]); print(test[Symbol(&#39;t&#39;)]); print(#t); } 结果： flutter: {Symbol(&quot;t&quot;): symbol test} flutter: symbol test flutter: symbol test flutter: Symbol(&quot;t&quot;) #t与Symbol(“t”)结果一致，由此可见，dart中的symbol更像是一个反射概念，而在js中是创建唯一标识的概念．","text":"由于近期有学习flutter的兴趣，因此首先学习其所需的编程语言dart.并采用dart与js对比差异的方式来进行学习． 基础数据类型 Number和String与js使用基本一致 Symbol的区别 js中，Symbol是将基础数据类型转换为唯一标识符，核心应用是将复杂引用数据类型转换为对象数据类型的键名．具体可参考js中Symbol,map,set 在 Dart 中，Symbol 是不透明的动态字符串名称，用于反映库中的元数据。用 Symbol 可以获得或引用类的一个镜像，概念比较复杂，但其实和 JavaScript 的用法基本上是一致的。例如，下面代码首先 new 了一个 test 为 Map 数据类型，设置一个属性 #t（Symbol 类型），然后分别打印 test、test 的 #t、test 的 Symbol(“t”) 和 #t。 void main() { Map test = new Map(); test[#t] = &#39;symbol test&#39;; print(test); print(test[#t]); print(test[Symbol(&#39;t&#39;)]); print(#t); } 结果： flutter: {Symbol(&quot;t&quot;): symbol test} flutter: symbol test flutter: symbol test flutter: Symbol(&quot;t&quot;) #t与Symbol(“t”)结果一致，由此可见，dart中的symbol更像是一个反射概念，而在js中是创建唯一标识的概念． undefined和null dart与js不同，dart是静态脚本语言，所以如果没有定义一个变量无法通过编译，js是存在脚本在运行期间变量没定义的情况． 为了避免因为一个变量无法通过编译，dart中不采用undefined，而是使用null,dart中null是弱类型object的子类型，不是基础数据类型．而所有数据类型，被初始化后没有被赋值的话自动赋值为null类型．Map和List 与js中Array和Map基本一致，但在js中不是基本数据类型，属于引用数据类型．分类不同，在用法和类型上没有什么差异．弱类型-var,object及dynamic dart也存在弱类型，使用var,object,dynamic来声明，同时为了避免弱类型导致客户端Crash的异常，Dart对弱类型加强了检验． var声明，第一次赋值将数据类型绑定，如果再更改类型，会在dart编译前就报错． object声明相当于js中的var声明赋值，在编译期间，object会对数据调用做一定判断并且报错，声明与调用必须是对应的类型．如声明为String类型，调用length就会报错．由于数据可能来自接口层，所以减少使用以避免运行时报错导致客户端Crash的异常． dynamic也是动态数据类型，但数据类型调用异常时只会在运行时报错，不会在编译前和编译期间导致报错，所以这点很危险． 基础运算符 dart是强数据类型因此没有”===”运算符．同时有一些类型测试运算符和js中类型转换以及typeof相似．不加介绍．??运算符 t??’test’即t!=null?t:’test’级联操作 允许对同一对象或者函数进行一系列操作，依次调用方法如testObj.add(&#39;t&#39;) ...delete(&#39;a&#39;) ...show() 函数 明显区别就是dart由于是强数据类型，所以在声明函数的时候可以增加一个返回值类型． 类命名构造函数 支持多个构造函数，实例化可以有选择class People{ String face; People.nice(){ this.face = &#39;nice&#39;; } People.bad(){ this.face = &#39;bad&#39;; } } void main(List&lt;String&gt;args){ People niceOne = new People.nice(); print(niceOne.face); People badOone = new Poeple.bad(); print(badOne.face) } 结果不言而喻访问控制 需要设置私有属性，就在方法或者属性前添加’_’抽象类和泛型类 库与调用dart库管理 库管理资源pub.dev中找到需要的库．在dart配置文件pubspec.yaml中添加就可以使用该库，就像在js的package.json中添加声明一样，也有dependencies和dev_dependencies开发dart库 开发好的库发表在pub.dev就可以了，和npm管理一致．如何发布按照官网 pubspec就像package一样，lib下，核心是对应的库文件.dart，是包含一个dart类，所以可以将私有方法用_保护，其他的可以被引用的模块调用．自己开发的无须发布在pub.dev的实现逻辑，可以放在src下．调用dart库． import &#39;package:startup_namer/pages/homepage.dart&#39; 其中package表示协议，比http好，避免性能影响，然后是库名/项目名，lib下的一个文件夹，具体引入的库文件名 比相对路径的方式要好，建议采用package方式，保证项目代码一致性 其中本篇文章提到的关于js中引用数据类型，以及前端工程化包括webpack,npm script会在后续整理后出相关文章．","categories":[{"name":"Web前端","slug":"Web前端","permalink":"/categories/Web前端/"}],"tags":[{"name":"dart","slug":"dart","permalink":"/tags/dart/"},{"name":"flutter","slug":"flutter","permalink":"/tags/flutter/"}],"keywords":[{"name":"Web前端","slug":"Web前端","permalink":"/categories/Web前端/"}]},{"title":"事件循环EventLoop(一)","slug":"js基础复习之事件循环EventLoop(一)","date":"2020-06-02T15:15:42.000Z","updated":"2020-07-16T02:33:25.027Z","comments":true,"path":"2020/06/02/js基础复习之事件循环EventLoop(一)/","link":"","permalink":"/2020/06/02/js基础复习之事件循环EventLoop(一)/","excerpt":"","text":"运行时概念栈 函数调用形成若干帧组成栈堆 对于js，对象处于堆中(非结构化的内存区域)队列 js运行时，会包含一个待处理消息的消息队列，而每个消息会有对应回调函数来处理消息． 在EventLoop的某个时刻开始，运行时优先处理先进入队列中的消息，然后被处理后移除队列，作为参数来调用与之关联的函数，即为该函数创建一个栈帧．此处反映了消息队列与执行栈之间彼此隔离而又互相联系的关系． 函数处理会处理直至栈为空，然后事件循环会读取下一个信息(注意理解这一点，对于判断事件循环带来的程序块执行先后顺序问题有很大帮助)事件循环 while (queue.waitForMessage()) { queue.processNextMessage(); } 类似于如此调用 执行至完成 每个消息完整的执行后，执行其它消息* 它当一个函数在执行时，不会被抢占，同时只有在它运行结束之后才能运行其它代码，这与C语言不同，如如果函数在线程中运行，可以在任何地方被终止,然后在另一个线程中运行其它代码． 缺点在于当一个消息占用太多时间来处理时，web应用会无法处理与用户的交互，因此需要减少单独处理时间，或是分割处理多个子消息． 添加消息 事件发生并且有事件监听器绑定在该事件上时，会把一个消息添加到消息队列．无事件监听器，消息会消失 例如一个点击事件处理器的元素被点击，会像其它事件一样产生一个类似的消息． setTimeOut实际上就包含了两个参数，第一个参数是消息，所以第二个参数反应的延迟时间不一定是真实的，而是要看消息队列中有没有正在处理的消息，若有，则需要等待处理完毕，然后会将消息添加到消息队列． 如果队列无消息并且栈也为空，则这段延迟过后，会马上处理消息．永不阻塞 js事件循环模型使得与其他语言不同，它永不阻塞．处理I/O通常通过事件和回调来执行．所以当一个应用正等待一个 IndexedDB 查询返回或者一个 XHR 请求返回时，它仍然可以处理其它事情，比如用户输入。","categories":[{"name":"Web前端","slug":"Web前端","permalink":"/categories/Web前端/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"/tags/javascript/"}],"keywords":[{"name":"Web前端","slug":"Web前端","permalink":"/categories/Web前端/"}]},{"title":"javascript的内存管理","slug":"js基础复习之内存管理","date":"2020-05-31T06:47:24.000Z","updated":"2020-07-16T02:33:18.115Z","comments":true,"path":"2020/05/31/js基础复习之内存管理/","link":"","permalink":"/2020/05/31/js基础复习之内存管理/","excerpt":"","text":"内存生命周期 分配你所需要的内存 使用分配到的内存读写 不需要时将其释放\\归还 javascript的内存分配 值初始化 函数调用 使用值 对分配内存进行读取和写入的操作，读取和写入可能是写入一个变量或者一个对象的属性值，传递函数参数 不需要时释放 垃圾回收器跟踪内存分配和使用，当分配内存不使用时自动释放．近似过程，无法判定 垃圾回收 引用 在内存管理的environment中，一个对象如果有访问另一个对象的权限，就叫一个对象引用另一个对象．对象对它原型的引用(隐式引用)，对它属性的引用(显式引用)． 对象包括函数作用域(全局词法作用域) 引用计数垃圾收集 最初级的垃圾收集算法 对象是否不再需要-&gt;对象有没有被其他对象引用，如果为0引用，对象被垃圾回收机制回收 限制：循环引用 标记-清除算法 对象是否不再需要-&gt;对象是否可以获得 定期从root对象-&gt;root引用的对象-&gt;… 可以获得所有可获得的对象和收集所有不可获得的对象 有0引用的对象总是不可获得的，但反之不一定，如循环引用(函数内部) 函数调用返回之后，对象从全局作用域下无法获得，所以定期会被垃圾回收器回收到． 限制：无法从根对象查询到的对象 简化定义一定有限制","categories":[{"name":"Web前端","slug":"Web前端","permalink":"/categories/Web前端/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"/tags/javascript/"}],"keywords":[{"name":"Web前端","slug":"Web前端","permalink":"/categories/Web前端/"}]}]}