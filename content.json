{"meta":{"title":"青山入我怀","subtitle":null,"description":"尔入我梦来","author":"LiJiajun","url":""},"pages":[{"title":"about","date":"2018-12-12T14:14:36.000Z","updated":"2020-03-16T10:41:30.000Z","comments":false,"path":"about/index.html","permalink":"/about/index.html","excerpt":"","text":"[さくら荘のhojun] 与&nbsp; Mashiro&nbsp; （ 真（ま）白（しろ） ） 对话中... bot_ui_ini()","keywords":"关于"},{"title":"bangumi","date":"2019-02-10T13:32:48.000Z","updated":"2020-03-16T10:41:30.000Z","comments":false,"path":"bangumi/index.html","permalink":"/bangumi/index.html","excerpt":"","text":"","keywords":null},{"title":"categories","date":"2020-07-03T01:45:35.000Z","updated":"2020-07-03T01:46:24.359Z","comments":true,"path":"categories/index.html","permalink":"/categories/index.html","excerpt":"","text":""},{"title":"client","date":"2018-12-20T15:13:35.000Z","updated":"2020-03-16T10:41:30.000Z","comments":false,"path":"client/index.html","permalink":"/client/index.html","excerpt":"","text":"直接下载 or 扫码下载：","keywords":"Android客户端"},{"title":"comment","date":"2018-12-20T15:13:48.000Z","updated":"2020-03-16T10:41:30.000Z","comments":true,"path":"comment/index.html","permalink":"/comment/index.html","excerpt":"","text":"念两句诗 叙别梦、扬州一觉。 【宋代】吴文英《夜游宫·人去西楼雁杳》","keywords":"留言板"},{"title":"donate","date":"2018-12-20T15:13:05.000Z","updated":"2020-03-16T10:41:30.000Z","comments":false,"path":"donate/index.html","permalink":"/donate/index.html","excerpt":"","text":"","keywords":"谢谢饲主了喵~"},{"title":"lab","date":"2019-01-05T13:47:59.000Z","updated":"2020-03-16T10:41:30.000Z","comments":false,"path":"lab/index.html","permalink":"/lab/index.html","excerpt":"","text":"sakura主题balabala","keywords":"Lab实验室"},{"title":"links","date":"2018-12-19T15:11:06.000Z","updated":"2020-03-16T10:41:30.000Z","comments":true,"path":"links/index.html","permalink":"/links/index.html","excerpt":"","text":"","keywords":"友人帐"},{"title":"music","date":"2018-12-20T15:14:28.000Z","updated":"2020-07-03T11:47:24.478Z","comments":false,"path":"music/index.html","permalink":"/music/index.html","excerpt":"","text":"","keywords":"喜欢的音乐"},{"title":"tags","date":"2018-12-12T14:14:16.000Z","updated":"2020-03-16T10:41:30.000Z","comments":true,"path":"tags/index.html","permalink":"/tags/index.html","excerpt":"","text":""},{"title":"rss","date":"2018-12-20T15:09:03.000Z","updated":"2020-03-16T10:41:30.000Z","comments":true,"path":"rss/index.html","permalink":"/rss/index.html","excerpt":"","text":""},{"title":"theme-sakura","date":"2019-01-04T14:53:25.000Z","updated":"2020-03-16T10:41:30.000Z","comments":false,"path":"theme-sakura/index.html","permalink":"/theme-sakura/index.html","excerpt":"","text":"Hexo主题Sakura修改自WordPress主题Sakura，感谢原作者Mashiro","keywords":"Hexo 主题 Sakura 🌸"},{"title":"video","date":"2018-12-20T15:14:38.000Z","updated":"2020-03-16T10:41:30.000Z","comments":false,"path":"video/index.html","permalink":"/video/index.html","excerpt":"","text":"var videos = [ { img: 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '放送时间: 2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' }, { img : 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' } ] .should-ellipsis{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:95%;}.should-ellipsis-full{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:100%;}.should-ellipsis i{position:absolute;right:24px;}.grey-text{color:#9e9e9e !important}.grey-text.text-darken-4{color:#212121 !important}html{line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}img{border-style:none}progress{display:inline-block;vertical-align:baseline}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}html{-webkit-box-sizing:border-box;box-sizing:border-box}*,*:before,*:after{-webkit-box-sizing:inherit;box-sizing:inherit}ul:not(.browser-default){padding-left:0;list-style-type:none}ul:not(.browser-default)>li{list-style-type:none}.card{-webkit-box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2);box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2)}.hoverable{-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s}.hoverable:hover{-webkit-box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19);box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19)}i{line-height:inherit}i.right{float:right;margin-left:15px}.bangumi .right{float:right !important}.material-icons{text-rendering:optimizeLegibility;-webkit-font-feature-settings:'liga';-moz-font-feature-settings:'liga';font-feature-settings:'liga'}.row{margin-left:auto;margin-right:auto;margin-bottom:20px}.row:after{content:\"\";display:table;clear:both}.row .col{float:left;-webkit-box-sizing:border-box;box-sizing:border-box;padding:0 .75rem;min-height:1px}.row .col.s12{width:100%;margin-left:auto;left:auto;right:auto}@media only screen and (min-width:601px){.row .col.m6{width:50%;margin-left:auto;left:auto;right:auto}}html{line-height:1.5;font-family:-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,Oxygen-Sans,Ubuntu,Cantarell,\"Helvetica Neue\",sans-serif;font-weight:normal;color:rgba(0,0,0,0.87)}@media only screen and (min-width:0){html{font-size:14px}}@media only screen and (min-width:992px){html{font-size:14.5px}}@media only screen and (min-width:1200px){html{font-size:15px}}.card{position:relative;margin:.5rem 0 1rem 0;background-color:#fff;-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s;border-radius:2px}.card .card-title{font-size:24px;font-weight:300}.card .card-title.activator{cursor:pointer}.card .card-image{position:relative}.card .card-image img{display:block;border-radius:2px 2px 0 0;position:relative;left:0;right:0;top:0;bottom:0;width:100%}.card .card-content{padding:24px;border-radius:0 0 2px 2px}.card .card-content p{margin:0}.card .card-content .card-title{display:block;line-height:32px;margin-bottom:8px}.card .card-content .card-title i{line-height:32px}.card .card-reveal{padding:24px;position:absolute;background-color:#fff;width:100%;overflow-y:auto;left:0;top:100%;height:100%;z-index:3;display:none}.card .card-reveal .card-title{cursor:pointer;display:block}.waves-effect{position:relative;cursor:pointer;display:inline-block;overflow:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;vertical-align:middle;z-index:1;-webkit-transition:.3s ease-out;transition:.3s ease-out}.waves-effect img{position:relative;z-index:-1}.waves-block{display:block}::-webkit-input-placeholder{color:#d1d1d1}::-moz-placeholder{color:#d1d1d1}:-ms-input-placeholder{color:#d1d1d1}::-ms-input-placeholder{color:#d1d1d1}[type=\"radio\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"radio\"]:not(:checked)+span{position:relative;padding-left:35px;cursor:pointer;display:inline-block;height:25px;line-height:25px;font-size:1rem;-webkit-transition:.28s ease;transition:.28s ease;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border-radius:50%}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border:2px solid #5a5a5a}[type=\"radio\"]:not(:checked)+span:after{-webkit-transform:scale(0);transform:scale(0)}[type=\"checkbox\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"checkbox\"]:not(:checked):disabled+span:not(.lever):before{border:none;background-color:rgba(0,0,0,0.42)}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):before{width:0;height:0;border:3px solid transparent;left:6px;top:10px;-webkit-transform:rotateZ(37deg);transform:rotateZ(37deg);-webkit-transform-origin:100% 100%;transform-origin:100% 100%}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):after{height:20px;width:20px;background-color:transparent;border:2px solid #5a5a5a;top:0px;z-index:0}input[type=checkbox]:not(:disabled) ~ .lever:active:before,input[type=checkbox]:not(:disabled).tabbed:focus ~ .lever::before{-webkit-transform:scale(2.4);transform:scale(2.4);background-color:rgba(0,0,0,0.08)}input[type=range].focused:focus:not(.active)::-webkit-slider-thumb{-webkit-box-shadow:0 0 0 10px rgba(38,166,154,0.26);box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-moz-range-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-ms-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)} 番组计划 这里将是永远的回忆 window.onload = function(){ videos.forEach(function(video, i){ $('#rootRow').append(` ${video.title} ${video.jp} ${video.status} ${video.title} ${video.jp} 放送时间: ${video.time} ${video.desc} ${video.status} `) }) }","keywords":"B站"}],"posts":[{"title":"How browser works 品读(一)","slug":"浏览器原理(一)","date":"2020-11-05T04:09:35.627Z","updated":"2020-11-05T04:14:12.175Z","comments":true,"path":"2020/11/05/浏览器原理(一)/","link":"","permalink":"/2020/11/05/浏览器原理(一)/","excerpt":"","text":"How browser works 品读(一)好久没有写博客了，因为实在感觉前端内容过于琐碎，于是没有发表，正好之前包括目前在持续学习浏览器原理相关的内容，这篇文章为了方便记录笔者阅读’How browser works’过程中的思考。 个人感受读完全篇’How browser works’,可知这篇文章首先是站在浏览器的高层结构(high level structure)，为我们介绍了浏览器的组件(抽象构成),而作者的主要精力放在介绍浏览器中rendering engine的工作。是的，渲染引擎自然是对于浏览器特别重要的一个组件，文章对于Parse HTML, parse CSS以及constructor render tree等rendering engine的工作都很细致，对于一般的前端开发人员，可以说已经很底层了。 但是需要注意的是，虽然文章对于渲染引擎这一部分的介绍比较充分,也会比较两大主流浏览器Chomre以及Firefox在相关功能实现采用的细微差异,但是文章对于整个浏览器架构，进程架构并没有充分的介绍。 由于这一点，容易导致开发人员对浏览器的认识产生偏差。对于这一部分的内容,我会在以后的文章中归纳总结，同时提出自己的过程。同时这篇文章的内容，我的总结会保留其主要逻辑。 浏览器高层结构(high lever structure)浏览器的主要组件 1.用户界面(The user interface):包括地址栏、前进/后退按钮、书签菜单等。除了浏览器主窗口显示的您请求的页面外，其他显示的各个部分都属于用户界面。 2.浏览器引擎(The browser engine):在用户界面和呈现引擎之间传送指令 3.呈现引擎(The rendering engine)负责显示请求的内容。如果请求的内容是 HTML，它就负责解析 HTML 和 CSS 内容，并将解析后的内容显示在屏幕上。 4.网络(Networking)用于网络调用，比如 HTTP 请求。其接口与平台无关，并为所有平台提供底层实现。 5.用户页面后端(UI backend)用于绘制基本的窗口小部件，比如组合框和窗口。其公开了与平台无关的通用接口，而在底层使用操作系统的用户界面方法。 6.JS解释器(JavaScript interpreter)用于解析和执行 JavaScript 代码。 7.数据存储(Data storage)这是持久层。浏览器需要在硬盘上保存各种数据，例如 Cookie。新的 HTML 规范 (HTML5) 定义了“网络数据库”，这是一个完整（但是轻便）的浏览器内数据库。 文章对于浏览器的组件归纳是基于功能出发，并不说明浏览器的结构层级是如何的，更多的是为了描述浏览器的功能。 文章提到Chrome 浏览器的每个标签页都分别对应一个呈现引擎实例。每个标签页都是一个独立的进程。原文是: It is important to note that Chrome, unlike most browsers, holds multiple instances of the rendering engine - one for each tab,. Each tab is a separate process. 我们需要注意的是，如今的Chrome对于渲染进程的安排并不像文中提到的那么简单，”Each tab is a separate process”,这里有一个浏览器上下文组的概念，可能后面的文章我会详细介绍，这里你只需要理解为页面通过引用方式与另一个页面关联，则它们处于同一个浏览器上下文组中，处于同一个浏览器上下文组中的页面,同时它们又同域，则它们会共享一个渲染进程。 然而本文的重点并不是这个，而是详细的分析了render engine做的工作，这里我们也发现了本文并不能使得我们在全局视角理解浏览器的工作原理。 渲染引擎(The rendering engine)这一部分我首先为你概括一下文章的主要逻辑。rendering engine的工作概括来说就是呈现请求来的内容。文章从rendering engine的工作流(basic flow)入手，主要介绍了四个步骤的细节操作。 首先是Parsing HTML to construct the DOM tree然后是Render tree construction以及Layout of the render treePainting the render tree. 引用一下主流程部分的一段中文翻译: 呈现引擎一开始会从网络层获取请求文档的内容，内容的大小一般限制在 8000 个块以内。 呈现引擎将开始解析 HTML 文档，并将各标记逐个转化成“内容树”上的 DOM 节点。同时也会解析外部 CSS 文件以及样式元素中的样式数据。HTML 中这些带有视觉指令的样式信息将用于创建另一个树结构：呈现树。 呈现树包含多个带有视觉属性（如颜色和尺寸）的矩形。这些矩形的排列顺序就是它们将在屏幕上显示的顺序。 呈现树构建完毕之后，进入“布局”处理阶段，也就是为每个节点分配一个应出现在屏幕上的确切坐标。下一个阶段是绘制 - 呈现引擎会遍历呈现树，由用户界面后端层将每个节点绘制出来。 需要着重指出的是，这是一个渐进的过程。为达到更好的用户体验，呈现引擎会力求尽快将内容显示在屏幕上。它不必等到整个 HTML 文档解析完毕之后，就会开始构建呈现树和设置布局。在不断接收和处理来自网络的其余内容的同时，呈现引擎会将部分内容解析并显示出来。 工作流中我们需要注意的是Webkit中的Render Tree(Gecko称为Frame Tree),是由Render Objects组成的,Chrome中的layout与Gecko描述的Reflow是一个过程，attachment是Webkit描述将DOM nodes与可视信息visial information进行connect创建DOM树的过程，需要注意的attach过程作用于Render Object的而不是整个Render Tree. 随后我会用一篇文章详细的介绍Parsing HTML的过程以及文中提到的细节。","categories":[{"name":"Web前端","slug":"Web前端","permalink":"/categories/Web前端/"}],"tags":[{"name":"浏览器","slug":"浏览器","permalink":"/tags/浏览器/"}],"keywords":[{"name":"Web前端","slug":"Web前端","permalink":"/categories/Web前端/"}]},{"title":"webGL缓冲区","slug":"WebGL缓冲区","date":"2020-11-05T03:57:11.580Z","updated":"2020-11-05T03:59:41.730Z","comments":true,"path":"2020/11/05/WebGL缓冲区/","link":"","permalink":"/2020/11/05/WebGL缓冲区/","excerpt":"","text":"WebGL缓冲区使用为什么需要缓冲区?首先我们需要明白,为什么需要缓冲区，因为当我们编写程序时，是需要给着色器传递顶点数据的，而当传递的顶点数据不止一个，就需要借助缓冲区，给着色器传递多个顶点数据。当然我们需要明白，GPU执行着色器程序的过程是并行的，我们总不可能将多个顶点分别传入着色器程序，然后分别运行，关于其中的并行处理机制，我们在介绍完创建缓冲区以及绑定缓冲区，配置变量从缓冲区读取数据之后进行介绍。 Process// positions是顶点数据 // 找到着色器程序中position对应变量的指针 var a_Position = gl.getAttribLocation(program, &#39;position&#39;); // 下面通过缓冲区给着色器传递多个顶点数据 // 1.创建缓冲区 var buffer = gl.createBuffer(); 2.绑定该缓冲区为WebGL当前缓冲区gl.ARRAY_BUFFER gl.bindBuffer(gl.ARRAY_BUFFER, buffer); 3.给绑定的缓冲区传递data gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW); 着色器中的变量需要使用强类型数据，因此使用js中的typedArray进行转化.而STATIC_DRAW表示提示WebGL我们不会频繁改变缓冲区的数据，便于WebGL做优化处理。 4.启用属性使得a_Position属性能够从缓冲区读取数据 gl.enableVertexAttribArray(a_Position); 5.设置从缓冲区读取数据的方式 // 每次取两个数据 var size = 2; // 每个数据的类型是32浮点数 var type = gl.FLOAT; // 不需要归一化处理数据 var normalize = false; // 每次迭代运行需要移动数据数 * 每个数据所占内存 到下一个数据开始 var stride = 0; // 从缓冲起始位置开始读取 var offset = 0; // 将a_Position变量读取数据的缓冲区指定为当前绑定的buffer gl.vertexAttribPointer( a_Position, size, type, normalize, stride, offset ) 同时，我们的a_Position属性(应该说是指针)绑定了当前的缓冲区，因此在重新使用bindBUffer绑定gl.ARRAY_BUFFER到其它缓冲区上时，我们的a_Position只能从当前缓冲区读取数据。 gl.vertexAttribPointer(tar, size ,type, normalize, stride, offset)解释一下这个函数做了什么:它将决定目标属性是如何从缓冲区读取数据的各参数的意义 target: 允许哪个属性读取当前缓冲区的数据 size: 一次取几个数据赋值给target,需要说明的是我们的缓冲区是提供给所有的顶点着色器使用的，也就是说，我们的数据不是传给一个顶点着色器中的一个顶点变量,而是根据规则分配给不同顶点着色器的顶点变量。而这里的a_Position是vec2类型，即每次接受两个数据。 type: 数据类型，一般都是浮点型。 normalize: 是否需要将非浮点数归一化 stride: 步长 offset: 偏移量 需要好好对比一下stride和offset的意义与区别，stride指定了每个顶点所包含数据的字节数。0是指一个属性的数据是连续存放的，在本利中，一个顶点只包含一个顶点位置属性，其有x,y分量，都是Float类型，所以顶点包含的数据字节数也就是两个Float32类型所占的字节数，因此占用8个字节。但由于缓冲区只为a_Position使用，因此可以使用0. 同样的，因为这一点，所以offset也为0，offset表示为一个步长的数据中，该target属性需要偏移多少字节才开始读取。同时说明，只有当出现多属性从一个缓冲区读取数据时我们才需要设置offset。 并行处理的特点 从片元着色器看并行处理以上工作完成了将数据传入缓冲区，同时GPU具有读取数据到指定的着色器变量中的能力。 因此在这之后我们进行调用绘图指令，执行着色器程序来完成绘图。 首先调用gl.clear清除画布再调用gl.drawArrays进行绘制 gl.clear(gl.COLOR_BUFFER_BIT); gl.drawArrays(gl.TRIANGLES, 0, points.length / 2); 我们此时的片元着色器程序如果是这样的 precision mediump float; void main(){ gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0); } 则会发现绘制出的三角形会被红色填充。这个过程也就印证了WebGL可以并行地对所有像素点同时运行片元着色器,也就是说图形中有多少像素点，着色器程序就被同时执行多少次。 从顶点着色器看并行处理当我们需要将每个顶点坐标设置为从缓冲区读取顶点数据相应值的一半时，需要每个顶点着色器分别依次计算吗？显然不需要，这里我们仍然利用并行计算。因此顶点着色器的以下代码可以并行计算顶点。 attribute vec2 position; void main() { gl_PositionSize = 1.0; gl_Position = vec4(position * 0.5, 1.0, 1.0); } gl_Position就是该顶点着色器的顶点坐标。每个不同的着色器顶点坐标互不干扰。 除此之外，顶点着色器还可以通过varing来向片元着色器传递数据如下: attribute vec2 position; varing vec3 color; void main() { gl_PointSize = 1.0; color = vec3(0.5 + position * 0.5, 0.0); gl_Position = vec4(position * 0.5, 1.0 ,1.0); } 片元着色器接受color precision mediump float; varying vec3 color; void main(){ gl_FragColor = vec4(color, 1.0); } 我们正常的思维是执行片元着色器程序时，由顶点着色器传递过来的color值会被正确接受，那这样推理，则会有多少顶点着色器程序执行，就会有多少片元着色器程序执行,这样只会在顶点处呈现颜色，可是真实的结果是三角形内部被填充了颜色，而且是渐变的。下面我们来解释一下其中缘由。 WebGL在执行片元着色器程序的时候，顶点着色器传给片元着色器的变量，会根据片元着色器的像素坐标对变量进行线性插值，利用线性插值，就使得像素点的颜色具有均匀渐变这一特点。 最后我们需要明白，在调用这一步时 gl.drawArrays(gl.TRIANGLES, 0, points.lenght/2); WebGL将对应的buffer数组传递给顶点着色器，再根据三角形图元，以及绘制顶点的偏移量和数量这些信息，来进行绘制。 总结 总之，WebGL缓冲区的使用非常有必要，同时我们需要了解GPU并行计算的特点，着色器程序的运行具有并行特点，利用这一点,像素点的处理效率有很大提升。 我们再总结一下WebGL完整的绘图流程，这对于开发而言也是很重要的。 创建WebGL上下文 创建着色器程序 将数据存入缓冲区(createBuffer(创建缓冲区),bindBuffer(绑定缓冲区),bufferData(给缓冲区传递数据)) 从缓冲区中读取数据(enableVertexAttribArray(启用属性)，vertexAttribPointer(设置属性缓冲区读取的配置,绑定到当前设置的绑定缓冲区)) 运行着色程序(clear,drawArrays) 当然，如果你的createBuffer,bindBuffer,以及enableVertexAttribArray可以在其它步骤下设置，只要保证具有核心步骤即可。","categories":[{"name":"Web前端","slug":"Web前端","permalink":"/categories/Web前端/"}],"tags":[{"name":"WebGL","slug":"WebGL","permalink":"/tags/WebGL/"}],"keywords":[{"name":"Web前端","slug":"Web前端","permalink":"/categories/Web前端/"}]},{"title":"ES6函数细节与rest运算符(review系列)","slug":"箭头函数与rest运算符","date":"2020-10-03T11:37:23.387Z","updated":"2020-10-03T11:39:27.164Z","comments":true,"path":"2020/10/03/箭头函数与rest运算符/","link":"","permalink":"/2020/10/03/箭头函数与rest运算符/","excerpt":"","text":"ES6函数细节与rest运算符形参与实参的关系形参默认值会影响到映射关系 var x = 1; function foo(x = x){ // 声明赋值时的rhs查询查询不到x,会报错 // Reference Error : x is not undefined console.log(&#39;1&#39;); } foo() var x = 1; function foo(x, y = function(){ x = 2; cnosole.log(x) }){ x = 3; y(); console.log(x); } 调用栈，记录了函数在哪个地方调用的, 通过控制台Sources查看，设置断点。 箭头函数this指向问题 默认绑定规则(优先值最低)function默认指向window严格模式下，默认指向undefined 隐式绑定谁调用就指向谁，即看在函数调用栈中的调用情况 显示绑定call(obj, a, b, c), apply(obj,[a, b , c]), bind(obj, a, b, c); new方式(优先级最高)new的过程就是在最后一步this指向实例化对象 优先级: new方式 &gt; 显示绑定 &gt; 隐式绑定 &gt; 默认绑定规则 箭头函数语法1参数只有一个，函数体只有一条语句，具有返回值 var f = a =&gt; a; | 相当于(但是性质不同，由于一个是函数表达式一个是函数声明，表现也不同如函数声明提升) var f = function(a){ return a; } 2参数不是一个时: var f = (a, b) =&gt; 5; | 相当于(但是性质不同，由于一个是函数表达式一个是函数声明，表现也不同如函数声明提升) function f(){ return 5; } 箭头函数与解构赋值解构赋值回顾: 解构赋值左侧若是对象，如果需要赋值的变量与右侧对象某键名相同，则可对应赋值，从而实现简写。 const full = ({first, last} = {})=&gt; first + &#39;&#39; + last; console.log(full({first: 3, last: 5})); 箭头函数作为函数参数var arr = [123321, 124 ,213, 1111]; var arr1 = arr.sort((a,b) =&gt; a - b); console.log(arr1); 以上说明箭头函数不是使用function进行声明定义的。 没有argumentsvar sum = (a, b) =&gt; { console.log(arguments); // 报错 return a + b; } sum(1, 23); rest/spread运算符用于展开或收集 收集实参var sum = (...args) =&gt; { console.log(args); console.log(args[0] + args[1]); } sum(1, 2); 收集余参let fn = (a, b, ...c) =&gt; { console.log(a, b, c); } fm(1, 2, 4, 5, 6, 7); // 收集剩余所有参数。 拓展运算符收集必须放在最后一个参数，否则会报错 展开数组function foo(x, y, z){ console.log(x ,y ,z); } foo(...[1, 2, 3]); // 展开数组 此处也可用apply foo.apply(null, [1, 2, 3, 4, 5]); 在其它上下文中拓展？let a = [2, 3, 4]; let b = [1, ...a, 5]; console.log(b) // 展开 从而替代 console.log([1].concat(a, [5])) ES6数组排序假设：传入参数方式为依次传入。 ES5实现 function sortNum(){ Array.prototype.slice.call(arguments).sort(function(a, b){ return a - b }) } sortNum(12, 431, 24, 1, 4, 135, 2, 35); ES6箭头函数+rest运算符 const sortNum = (...args) =&gt; args.sort((a, b) =&gt; a - b ); console.log(sortNum(12, 431, 24, 1, 4, 135)); 函数length问题console.log(function (a){}.length) ;//1 console.log((function(b,c,d = 0,...a){}).length); // 2 访问的是形参长度length属性只包括实际形参的长度，不包含设置了默认值的形参以及使用rest运算符的参数","categories":[{"name":"Web前端","slug":"Web前端","permalink":"/categories/Web前端/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"/tags/ES6/"},{"name":"javascript","slug":"javascript","permalink":"/tags/javascript/"}],"keywords":[{"name":"Web前端","slug":"Web前端","permalink":"/categories/Web前端/"}]},{"title":"let进阶与const(review系列)","slug":"let进阶与const","date":"2020-10-03T11:36:14.764Z","updated":"2020-10-03T11:36:59.135Z","comments":true,"path":"2020/10/03/let进阶与const/","link":"","permalink":"/2020/10/03/let进阶与const/","excerpt":"","text":"Letbabel一下var arr = []; for(let i = 0 ; i &lt; 10; i ++){ arr[i] = function(){ console.log(i); } }; for(var k = 0; k &lt; 10; k++){ arr[k](); } babel后的代码: var arr = []; // 借助闭包,模拟 var _loop = function _loop(i){ arr[i] = function(){ console.log(i); }; }; for(var i = 0; i&lt; 10; i++) { _loop(i); } for(var k = 0; k &lt; 10; k++){ arr[k](); } 可见:块级作用域中的var 提升到当前所处作用域的顶端 constconst 声明 一旦定义的同时必须赋值,否则报错 const a; // 报错 暂时性死区const 会产生块级作用域，同时不能提升，有暂时性死区。与let相同,不能重复声明。 “常量”?考虑const 声明值类型为引用值类型的变量 const obj = {}; obj.name = &#39;zhangsan&#39;; console.log(obj); 解释: const保证变量指向堆内存不变,即指针不变，保存的地址指向的栈中值可以变化。 const声明原始值类型变量时，由于给变量赋值时，会改变变量代表的栈内存位置，而const保证了变量指向内存位置不变。 对象冻结const 并不能变量不改变,当这个变量的值目前为一个对象时，栈中的值可能会发生改变，因此实现一个无法改变的真正的常量需要借助其它工具。 这个工具就是Object.freeze(); const obj = []; Object.freeze(obj) obj[2] = &#39;zhangsan&#39;; console.log(obj) //[] 对象属性冻结(深度冻结) function myFreeze(obj){ Object.freeze(obj); for(var key in obj){ if(typeof(obj[key]) === &#39;object&#39; &amp;&amp; obj[key] !== null){ Object.freeze(obj[key]); } } } 测试: var person = { son: { lisi: &#39;18&#39;, zhangsan: &#39;19&#39; }, car: [&#39;benz&#39;, &#39;mazda&#39;, &#39;BMW&#39;] } myFreeze(person); person.son.wangwu = 20; person.car[3] = &#39;xxxx&#39;; console.log(person); const应用打开node文档查询http/request等其它板块 如下: const http = require(&#39;http&#39;); 模块的最后 return new + 构造函数 使用const得到的是实例化的对象，我们指定这个变量指向堆内存的地址不可改变。 同时，在引入模块的最后通过”return new + 构造函数”的形式。 某种程度上是为了不允许const对象对父级构造器进行更改,因此不暴露父级构造器而是实例化对象。 全局污染的有效措施问题:window的属性与全局变量是等效的,导致很多问题，写错变量名后，直接挂载到window上。 const/let解决ES6为了改变现状，保持兼容性.由于function 和 var 允许声明变量到顶层对象上,let/const是为了解决这种问题而出现的class也是。一般情况下使用let/const可以减少变量全局污染。 暂时性死区TDZ(Temporal Dead Zone)var x = 1; { let x = x; //暂时性死区，不光体现在变量无法提升，而且在let声明变量并赋值时,RHS查询相同名称的变量时无法在同级作用域以及向上级作用域中查找. console.log(x); // 报错，未定义 }","categories":[{"name":"Web前端","slug":"Web前端","permalink":"/categories/Web前端/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"/tags/ES6/"},{"name":"javascript","slug":"javascript","permalink":"/tags/javascript/"}],"keywords":[{"name":"Web前端","slug":"Web前端","permalink":"/categories/Web前端/"}]},{"title":"ES6前置知识(review系列)","slug":"ES6前置知识","date":"2020-10-03T11:35:06.233Z","updated":"2020-10-03T11:35:59.352Z","comments":true,"path":"2020/10/03/ES6前置知识/","link":"","permalink":"/2020/10/03/ES6前置知识/","excerpt":"","text":"ES6代码的转译 所需工具 ES6语法编译成ES5以下语法: babel-编译工具(理解为代码块，功能块) 需要npm安装 npm安装babel相关工具 babel-preset 我们指定的规则集为:babel-preset-env npm i babel-preset-env –save-dev安装到当前文件夹 .babelrc文件(rc是run command运行命令的简写的)的配置{ &quot;presets&quot;: [&quot;babel-preset-env&quot;] } 安装babel-cli –save-dev 安装babel脚手架工具(提供一系列命令) npm i babel-cli --save-dev 在”script”中添加 &quot;build&quot;: &quot;babel app.js -o bundle.js&quot; 指示babel转义后output到bundle.js &quot;babel src -d lib&quot; 命令行中使用命令,进行转义 npm run build app.js var arr = []; for(let i = 0; i &lt; 10; i++){ arr[i] = (() =&gt; { console.log(i); })(i) } 配置执行相应的文件 &quot;script-name&quot;: &quot;babel-node ./src/app.js&quot; 或者执行也可以直接用node babel更多工具babel-core：让部分代码转码 babel-register：利用Require钩子自动编译 app.js var babel = require(&quot;babel-core&quot;); app.js require(&quot;babel-register&quot;); var obj = new Map(); // 新的API没有被转码，通过babel-polyfill插件进行转换成相应浏览器能的代码 console.log(obj); babel-polyfill: require(&quot;babel-polyfill&quot;); 其他方式转义也可以通过babel提供的在线的工具，获取浏览器兼容的babel后的js代码 浏览器当中使用ES6代码在浏览器中引入cdn文件,babel官网提供 &lt;script type=&quot;text/babel&quot;&gt; // 代码 &lt;/script&gt; Traceur是谷歌提供的转码工具。在浏览器中使用，同样需要引入script文件 https://node.greennode关于ES6语法支持情况不错因此我们使用node环境测试ES6代码即可","categories":[{"name":"Web前端","slug":"Web前端","permalink":"/categories/Web前端/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"/tags/ES6/"},{"name":"javascript","slug":"javascript","permalink":"/tags/javascript/"}],"keywords":[{"name":"Web前端","slug":"Web前端","permalink":"/categories/Web前端/"}]},{"title":"块级作用域(review系列)","slug":"块级作用域","date":"2020-10-03T11:31:47.933Z","updated":"2020-10-03T11:34:23.402Z","comments":true,"path":"2020/10/03/块级作用域/","link":"","permalink":"/2020/10/03/块级作用域/","excerpt":"","text":"# 块级作用域(review系列) kiss原则解决变量污染问题keep it simple stupid let与块级作用域解决变量污染问题 形式上的块级作用域 if(1){ } for(; 1; ){ break; } { } let 声明let a = 1; let a = 2; 运行代码 node app.js 报错，重复定义 let声明特征 let 声明的变量在同一作用域下不可被重复声明`jsfunction test(){ let a = 1; var a = 2;} ```js function test(a){ let a = 10; console.log(a); } 报错, a已被定义 function test(a){ { let a = 10; console.log(a); // 10 } console.log(a); //undefined } let 不会声明提升，会产生一个暂时性死区 console.log(a); // 报错，未被定义 let a = 10; 函数中也一样 function test(){ console.log(a); let a = 10; } test(); 与var对比 var a = a; console.log(a); // undefined let b = b; console.log(b); //报错 let暂时性死区的影响： function test(x = y, y = 2){ console.log(x, y); } test(); // y is not defined console.log(typeof a); // 报错,是由于let引起的暂时性死区引起的。 let a; let 只能在当前的作用域下生效`js{ let a = 2;} console.log(a); ## 隐式let for循环条件中的i属于块级作用域 ```js for(let i = 0; i &lt; 10; i++){ } console.log(i); // 报错,i is not defined var声明的变量不产生块级作用域问题 情形一: var arr = []; for(var i = 0; i&lt; 10; i++){ arr[i] = function(){ console.log(i); } } for(var i = 0; i &lt; 10; i++){ arr[i](); } // 0-9 情形二 for(var i = 0; i &lt; 10; i++){ i = &#39;a&#39;; console.log(i); // 只打印一次a } for(var i = 0; i &lt; 10; i++){ var i = &#39;a&#39;; console.log(i); // 只打印一次 a } 原因是var 不存在块级作用域问题 情形三 for(let i = 0; i &lt; 10; i++){ i = &#39;a&#39;; console.log(i); // 依然只打印一次a } for(let i = 0; i &lt; 10; i++){ var i = &#39;a&#39;; console.log(i); // 报错,在同一作用域下 // 因为var声明的i与let声明的i在同一作用域下，var会有变量提升，而let规定声明的变量不能重复声明,因此会报错 } 情景四: for(let i = 0; i &lt; 10; i++){ let i = &#39;a&#39;; console.log(i); // 如果在同一块级作用域下，会报错，但是打印出a. } 由此说明: 两个i所在的块级作用域不是同一个块级作用域()作用域是父级作用域。{}内是子级作用域 babel可能出现问题if(1){ let a = 1; { let a = 10; console.log(a); } } let 本质上就是为了js增加块级作用域而出现的 babel后可以看到babel后的代码，转码之后发现以上代码处理为 if(1){ var a = 1; { var _a = 10; console.log(_a); } } 有时候会无法成功转义 for(let i = 0; i &lt; 10; i++){ let i = &#39;a&#39;; console.log(i); } 本应该出现10个a,但 是转义后却仍然是一个a。 块级作用域与函数函数只能在函数或顶层作用域中声明. ES5认为在{}块级作用域声明函数不合法 ES6做出妥协:如下都可以声明函数 if(i){ function test(){} }; try{ function test(){} } catch(e) { function test(){} } 但是不推荐在块级作用域中直接进行函数声明,而推荐使用函数表达式来完成目的 块级作用域设置返回值无意义var a = for(; i ;){ return } 草案: do{ return } 块级作用域与函数立即调用块级作用域是否与函数的立即调用相同? 不是，只能相互模拟，但也存在问题，比如函数的立即调用具有返回值，并且在外部可以接收。块级作用域是在外部无法访问作用域中VO中存储的变量。","categories":[{"name":"Web前端","slug":"Web前端","permalink":"/categories/Web前端/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"/tags/ES6/"},{"name":"javascript","slug":"javascript","permalink":"/tags/javascript/"}],"keywords":[{"name":"Web前端","slug":"Web前端","permalink":"/categories/Web前端/"}]},{"title":"箭头函数(review系列)","slug":"箭头函数","date":"2020-10-03T11:28:07.848Z","updated":"2020-10-03T11:39:29.336Z","comments":true,"path":"2020/10/03/箭头函数/","link":"","permalink":"/2020/10/03/箭头函数/","excerpt":"","text":"箭头函数(review系列)箭头函数的注意点返回对象前加一个(),防止引擎误读成代码块 (a, b) =&gt; ({a: 3, b: 4}); 箭头函数的本质箭头函数中的this指向的规则不是四大规则之一 主要区别有以下三点: this是由外层函数静态作用域来决定的 =&gt; 不能作为构造函数来使用 没有arguments对象， 用rest运算符替代() yield命令不能生效， 在generator函数中 依次来看 function foo(){ console.log(this); return (a) =&gt; { console.log(this.a); } } var obj1 = {a: 2}; var obj2 = {a: 3}; var bar = foo.call(obj1); bar.call(obj2); // 2 const person = { eat(){ console.log(this); }, drink: ()=&gt;{ console.log(this); }, } person.eat(); //person调用, eat函数执行时指向调用者person person.drink(); // window. 箭头函数使用场景举例 &lt;button id=&quot;button&quot;&gt; &lt;/button&gt; ES5 (function(){ function Button(){ this.button = document.getElementsById(&#39;button&#39;); } Button.prototype = { init(){ this.bindEvent(); }, bindEvent(){ this.button.addEventListener(&#39;click&#39;,this.clickBtn.bind(this), false); // 不友好 }, clickBtn(){ console.log(&#39;xxx&#39;); console.log(this); } } new Button().init(); })(); (function(){ function Button(){ this.button = document.getElementsById(&#39;button&#39;); } Button.prototype = { init(){ this.bindEvent(); }, bindEvent(){ this.button.addEventListener(&#39;click&#39;,(e)=&gt; {this.clickBtn(e)},false; // Change }, clickBtn(e){ console.log(e) console.log(this); } } new Button().init(); })(); 不要用bind(this)这种显示改变this指向的丑陋做法。而是用箭头函数。 在执行时其中的this与普通函数不同，它指向与定义的位置有关而与调用方式即函数调用栈无关(请见:You don’tkonw JS)，定义时外层函数作用域中this指向即为箭头函数执行的this指向。 You don’tkonw JS中还把这种行为与静态作用域类比，从某种角度this除了在箭头函数中有类似静态作用域的行为，其它的地方都类似于动态作用域，即运行时再绑定。 箭头函数的嵌套 function foo(){ return () =&gt; { return () =&gt; { return () =&gt; { console.log(&#39;id&#39;, this.id); } } } } var f = foo.call({id: 1}); var f1 = f.call({id: 2})()(); var f2 = f().call({id: 3})(); var f3 = f()().call({id: 4}); 箭头函数中的this是固化的，箭头函数中实际上本身在函数执行期没有自己的this. 下面代码中的this全部引用的是foo函数的this(可以理解为通过作用域链查找) function foo(){ console.log(this); return () =&gt; { console.log(this); return () =&gt; { console.log(this); return () =&gt; { console.log(this); console.log(&#39;id&#39;, this.id); } } } } this指向是固化的，函数内部并没有自己的this,只能够通过父级作用域来获取到this,this实际上是闭包导出的this。 2.不能当做构造函数使用:bind,apply,call. 箭头函数不存在arguments不存在arguments时，其需要RHS查找arguments时只能通过作用域链查找： var test = () =&gt; { console.log(arguments); } test(); 此问题与this指向实质一样的，通过闭包拿到的是父级的arguemnts.这里应该是闭包，原因使用setTimeOut，会将callback放到任务队列中后续会执行,callback定义在foo函数内部(当然这里是箭头函数表达式，不过它依然拥有自己的静态作用域)，在此时foo函数的argumnts被箭头函数作用域链引用了，因此在执行异步任务时，调用callback内部的代码，打印出的arguments实际上是foo在上次执行时产生的AO中的arguments. function foo(){ console.log(arguments); setTimeout( () =&gt; { console.log(arguments); }); } foo(1, 2, 3, 4, 5, 6, 7) 反映出来的问题是出来箭头函数中没有arguments(否则会RHS查询到自己函数内部的arguments),同时arguments如同普通变量一样，变量作用域是静态作用域，因此按照作用域链的规则进行查找。 不适用场景function insert(value) { return { into: function(array){ return { after: function(afterValue){ array.splice(array.indexof(afterValue) + 1, 0, value); return array; } } } } } console.log(inset(5).into[1,2,3,4,6,7,8].after(4)); // [1,2,3,4,5,6,7,8] 简洁，但不推荐，代码不易读 let insert = (value) =&gt; ({ into: (array) =&gt; ({ after: (afterValue) =&gt; { array.splice(array.indexof(afterValue) + 1, 0, value); return array; } }) }) console.log(inset(5).into[1,2,3,4,6,7,8].after(4)); 总结箭头函数适用场景规律 简单的函数表达式，得出唯一的return的计算值,函数内部没有this的引用时。没有递归，事件绑定，解绑定,考虑用箭头函数的方式重构代码 [12, 3, 1234, 1, 4].sort((a, b)=&gt; a - b); 内层函数表达式，需要调用this, var self = this 或者 bind(this)显示绑定this指向，确保this指向正确时，能考虑用箭头函数替代，因为这两种情况下的this必定与外层函数作用域中的this指向相同，因此避免了复杂的操作方式以改变this 拓展运算符的应用依赖于封装函数 var args = Array.prototype.slice.call(arguments); function sortNumber(){ return Array.prototype.slice.call(arguments).sort(function(a, b) =&gt; return a - b); } const sortNumber = (...numbers) =&gt; numbers.sort((a,b) =&gt; a - b); 不适用场景规律 当函数声明，执行语句比较多的情况，还需要用到递归，引用函数名，以及事件绑定，解绑定，避免用箭头表达式","categories":[{"name":"Web前端","slug":"Web前端","permalink":"/categories/Web前端/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"/tags/ES6/"},{"name":"javascript","slug":"javascript","permalink":"/tags/javascript/"}],"keywords":[{"name":"Web前端","slug":"Web前端","permalink":"/categories/Web前端/"}]},{"title":"深究不同情形下事件处理函数中的this","slug":"详解事件处理函数中的this","date":"2020-08-03T14:48:48.623Z","updated":"2020-08-03T16:18:45.876Z","comments":true,"path":"2020/08/03/详解事件处理函数中的this/","link":"","permalink":"/2020/08/03/详解事件处理函数中的this/","excerpt":"","text":"深究不同情形下事件处理函数中的this由于回顾React官方文档事件处理part时注意到了一些问题，因此决定经过相应调查和实践后记录下一些细节与想法．相信本篇文章能解释清楚不同事件处理中的this指向问题．后续会在React复习过程中记录更多细节的探索过程． 问题来源class Test extends React.Component { handleClick () { this.setState({}); } render () { return &lt;button onClick={this.handleClick}&gt;&lt;/button&gt; } } 根据文档，我们知道这里会报Cannot read property ‘setState’ of undefined.于是我们明白应采用bind方法改变this指向或者采用箭头函数．如下 1.bind //这是jsx &lt;button onClick={this.handleClick.bind(this)}&gt;&lt;/button&gt; 2.箭头函数： handleClick=()=&gt;{ this.setState({}); } 我们先不去谈这两种方式为何能够解决问题，而是思考为什么会出现this指向undefined的情况？ 关键点突破我们不妨先看这一段比较经典的代码． // 使用 ES6 的 class 语法 class Cat { sayThis () { console.log(this); // 这里的 `this` 指向谁？ } exec (cb) { cb(); } render () { this.exec(this.sayThis); } } const tom = new Cat(); tom.render(); // 输出结果是什么？ 结果是什么呢．由于this指向undefined，因此结果为undefined而换做以下代码 const jerry = { sayThis: function () { console.log(this); // 这里的 `this` 指向谁？ }, exec: function (cb) { cb(); }, render: function () { this.exec(this.sayThis); }, } jerry.render(); // 输出结果是什么？ 结果变为了window.其实结果并不意外，原因是this的指向与函数的显示调用者有关．如obj.eat为一个函数，我们可以用它给另一个函数对象赋值，则f1=obj.eat,obj.eat与window.f1在控制台console.log出来的结果相同．而this的指向却发生了变化. 我们需要明白不用调用者显式调用一个函数时，非严格模式下，js解释器会把f1()当做f1.call(global)是一样的． 开启了严格模式则在这种情况下，不会自动绑定到全局对象，因此this指向undefined. 如果你使用了 ES6 的 class 语法，所有在 class 中声明的方法都会自动地使用严格模式 这是相当重要的一点． 我们此时再回顾上面的两端代码，我们会发现当时我们传入的函数传递给了形参cb，相当于给cb赋值了，因此执行cb()代码时是没有显式调用者的． 新的疑点我们注意到上述的情形是当被调函数作为参数传递给函数的形参时会出现this指向不明的问题．然而例如 onClick = {this.handleClick} 这类绑定事件监听函数的方法是与上述情况等同的吗？也就是说this.handleClick会作为被调函数传递给形参？我们又联想到之前学习到以xx.addEventListner()给对象绑定事件监听函数的方法，而此类方法的结果是this指向当前对象，这又是怎么一回事呢？ 梳理思路寻找答案前面提到了当函数作为方法调用时，this指向调用该方法的对象， 当函数作为嵌套函数调用时， this指向全局对象（非严格模式下）或者undefined（严格模式）而不是其外包函数的上下文． 因此一个合理的解释是: addEventListener中的事件函数默认是作为调用addEventListener的对象的方法，也就是会放入到该对象的listener数组中（设对象的监听器方法用listener存储），在面对特定事件时，会直接调用listener中的方法，那么调用者即是该对象． 而不是采用嵌套函数调用，即不是作为函数参数以传递给形参的这种方式的调用． 同时我们也推出，无论是传给addEventListener的参数是一个函数名还是完整的匿名函数，其实相当于给obj的listner数组里赋值，最终调用时它们都成为了obj的一个方法，即被obj调用． 那么其他绑定事件处理函数的方式中的this呢?我们发现addEventListener和dom元素添加内联函数作为事件处理函数的结果相似，如例子 &lt;button onclick=&quot;alert(this.tagName.toLowerCase())&quot;&gt; show this &lt;/button&gt;//输出button 从输出结果可知this指向的是button.这种给html的onclick赋值的方式有两种，一种是添加内联函数，一种是采用以下这种方式，而这种方式的this指向window. function f1(){ alert(this.tagName.toLowerCase() } &lt;button onclick=&quot;f1()&quot;&gt;... 其实我们已经能够合理解释为什么两者this指向不同了，原因是赋值给onclick属性后，我们可以想象是这样的情形： javascript引擎将属性内容保存为字符串，而在当用户点击该button时，则会将会对内容进行评估．而如果是一段代码字符串，是button调用的，因此this自动绑定在button上.而第二种情况，onclick属性内容是f1(),在点击button时，会执行f1()，其中f1没有显示调用者，因此f1的对象指向window.要想传入this,其实只需要将this作为参数传给f1，即f1(this)，并在f1内用变量接收，此时的this指向的是button． 其实还有另外一种情况，即利用obj.onclick给dom元素增加事件处理函数，obj.onclick = f1,这种情况下，先给出结果，this指向obj.可知其确实与在html元素上直接添加的结果不一样．而出现这样的结果原因只可能是在调用函数f1时，函数调用者是obj.也就是说因为赋值，使得调用的目标被改变，不再是f1,而是obj的一个方法，可以看出这是与addEventListener的机理和结果相似的． 总结本篇文章分析了各种不同条件下的事件处理函数中this的指向问题，既给出了结果，也给出了分析过程，对于我个人而言收获还是蛮大的，知其然，更要知其所以然，良好的分析习惯有利于更长久的学习．同时分析过程当然可能出现问题，欢迎指正． 最后给出结论： React中绑定时间函数的方式://jsx {&lt;button onClick={f1}&gt;&lt;/button&gt;} this指向undefined(严格模式) 相当于直接在html上添加事件处理函数//html &lt;button onClick=&quot;f1()&quot;&gt;&lt;/button&gt; this指向window(非严格模式) html上添加内联函数//html &lt;button onclick=&quot;alert(this.tagName.toLowerCase())&quot;&gt;&lt;/button&gt; this指向button 与下面这两种结果也一样． 将上述事件处理函数应用于以下情形： obj.addEventListener /obj.onclick,this都指向obj. 其实核心仅仅在于判断函数是作为方法调用还是作为嵌套函数调用．而箭头函数更加单纯，其实更简单，因此不加讨论．","categories":[{"name":"Web前端","slug":"Web前端","permalink":"/categories/Web前端/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"/tags/javascript/"},{"name":"React","slug":"React","permalink":"/tags/React/"}],"keywords":[{"name":"Web前端","slug":"Web前端","permalink":"/categories/Web前端/"}]},{"title":"ES6重难点细解","slug":"ES6重难点细解","date":"2020-07-29T11:46:57.418Z","updated":"2020-07-29T13:12:11.415Z","comments":true,"path":"2020/07/29/ES6重难点细解/","link":"","permalink":"/2020/07/29/ES6重难点细解/","excerpt":"","text":"ES6重难点细解解构赋值核心点&nbsp;&nbsp;详细请看掘金上的这篇文章ES6系列解构赋值全解析&nbsp;&nbsp; 解构赋值的出现避免了赋值过程中循环的嵌套与复杂代码的产生． 对象的解构赋值 与对象属性同名的变量能够被成功赋值，如： let details = { firstName:&#39;Code&#39;, lastName:&#39;Burst&#39;, age:22 } const {firstName,age} = details; console.log(firstName); // Code console.log(age); // 22 不同名的变量通过映射赋值，通过冒号映射，如： const person = { name: &#39;jsPool&#39;, country: &#39;China&#39; }; const {name:fullname,country:place} = person; console.log(fullname); // jsPool console.log(place); // China 默认值，应用于当属性不存在时，可以用=指定一个默认值* 嵌套对象与此相似． 数组的解构赋值 解构索引对应的值，用变量按顺序接收，因此可用”,”号占位省略元素．如 let list = [221,&#39;Baker Street&#39;,&#39;London&#39;]; let [houseNo,,city] = list; console.log(houseNo,city);// 221 , London 不定元素let colors = [&#39;red&#39;,&#39;green&#39;,&#39;blue&#39;]; let [firstColor,...otherColors] = colors; console.log(firstColor); // red console.log(otherColors); // [&#39;green&#39;,&#39;blue&#39;] 解构赋值的应用场合： 交换变量值：[x, y] = [y, x] 返回函数多个值：const [x, y, z] = Func() 定义函数参数默认值：function Func({ x = 1, y = 2 } = {}) {} 定义函数参数：Func([1, 2]),在调用时会将1,2传递给[x,y]中的x和y． 提取JSON数据：const { name, version } = packageJson 遍历Map结构：for (let [k, v] of Map) {} 输入模块指定属性和方法：const { readFile, writeFile } = require(“fs”) 函数拓展 可为参数设置默认值，且设置之后，函数进行声明初始化时，参数会形成一个单独的context,作用域在初始化结束后消失,如: var x = 1; function f(x, y = x) { console.log(y); } f(2) // 2 调用函数f时，参数形成单独的作用域，在此作用域中，默认变量x指向第一个参数x而不是全局变量x let x = 1; function f( y = x ) { let x = 2; console.log(y); } f() // 1 在y=x形成的作用域中，变量x没有定义因此指向外层变量x，调用时，函数体内部的局部变量x无法影响默认值变量x． tips:可用延展运算符作为函数参数接受多个值 箭头函数: 箭头函数如果返回一个对象，则在外面加一个括号． 由箭头函数这引申出的this指向问题，可看掘金的这篇文章js的this指来指去到底指向哪 注意setTimeout执行环境是window,因为是window.setTimeout 普通function调用与new构造函数function创建出来的实例对象this指向不同．所以非实例化(new)调用function，this都指向window 对象中创建的函数中的this始终指向最后一个调用它的对象 闭包中的this指向，闭包函数具有匿名函数自执行的特性，默认this指向是挂在window下的 箭头函数中的this为定义时绑定，就是绑定最近一层非箭头函数的this，对象中箭头函数this指向window且无法改变 多层对象嵌套里箭头函数的this和最外层保持一致． const obj = { a: function() { console.log(this) }, b: { c: () =&gt; {console.log(this)} } } obj.a() //没有使用箭头函数打出的是obj obj.b.c() //打出的是window对象！！ 对象拓展与Map,Symbol,Set数组与对象拓展以及 Symbol,Set和Map Symbol常用在为对象取独一无二的属性名时 直接Symbol()调用，接受字符串为描述，Symbol值能转为布尔值 Symbol作为对象时不能用.运算符，因为.运算符的后面必须是一个字符串，因此用obj[s] 属性名不能被常规方法遍历得到，即不能出现在for…in,for…of循环中，Object.keys(),Object.getOwnPropertyNames()得到，可以用getOwnPropertySymbols得到所有的属性名． Symbol.for查询，返回一个Symbol值，没有则新建． Symbol.keyFor返回一个已登记的Symbol类型值的key．Symbol.for为Symbol登记的名字是全局环境的．* Set类似于数组，但成员值都是唯一的．可直接用于数组去重[…new Set(array)] 常见方法有add,delete,has,clear* Set实例有四个遍历方法,keys,values,entries,forEach同Map Map类似于对象，是键值对的集合，但是键的范围很大，包括对象都可以是键． 常见方法有：set(key,val),get,delete,has,clear js的四种for循环掘金上的这篇文章讲解的非常到位：js的四种for循环","categories":[{"name":"Web前端","slug":"Web前端","permalink":"/categories/Web前端/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"/tags/javascript/"}],"keywords":[{"name":"Web前端","slug":"Web前端","permalink":"/categories/Web前端/"}]},{"title":"egret游戏开发","slug":"egret游戏开发","date":"2020-07-16T02:30:04.499Z","updated":"2020-07-16T02:36:08.761Z","comments":true,"path":"2020/07/16/egret游戏开发/","link":"","permalink":"/2020/07/16/egret游戏开发/","excerpt":"","text":"引言游戏目前阶段有以下需求： 制作英雄图demo与相关动作特效 探究实现遮罩与碰撞检测 缓动过程的事件处理 探究子弹类的处理 探究寻路算法 结合egret的h5游戏开发指南，以及基础知识的补充，可以对这些问题有具象化的认识，而不是无从下手，因此对核心内容进行自己的一些总结，部分摘自指南，部分是尝试过程中的结论。 游戏基础显示对象 显示对象是能参与渲染的对象的抽象表示 需要了解的是DisplayObject类是显示对象基类。 Sprite类，是用来绘制矢量图形/充当容器。 Bitmap显示位图 MovieClip类，也是继承自显示对象类，因此我们可以通过该类制作帧动画，并拥有显示对象类的所有方法后面会给出例子。 Shape类，用来绘制矢量图形 …. 显示列表：显示对象加入显示列表中才能被渲染 常见的:addChild就是让显示对象加入显示列表，而addChild的调用者是显示容器，也就是说只有显示容器可以调用，且其可以嵌套。 DisplayObject与DisplayObjectContainer的关系 DisplayObjectContainer继承自DisplayObject类，因此显示容器也具有显示对象的属性和方法。Sprite是显示容器，Shape是显示对象。也正是因为显示对象容器继承自显示对象，addChild也可以作用于容器。 Shape类绘制矢量图在我们的项目中使用不多暂不多解释，有需求再去查api文档即可。 必要时可创建容器，集成一些相联的显示对象组件，进行处理，增删显示对象 在显示列表删除显示对象，即结束显示对象的渲染，如this.addChild(#一个帧动画#)，帧动画可以使用stop方法停止，如果想结束其渲染，可以使用this.removeChild。可见显示对象独立于显示列表也就是说removeChild之后需要在内存中删除才算彻底销毁。 显示对象只能加入到一个显示列表中 显示对象设置的x,y坐标属性是相对坐标系，其中显示对象具体位置也与锚点有关(后续会有相关运用) 遮罩与碰撞 显示对象都具备遮罩功能 使用egret.Rectangle(firstx,firsty,lastx,lasty)创建一块矩形区域rect， 然后设置obj.mask = rect.即设置了遮罩。 obj.mask=null取消。 碰撞检测 非精确碰撞检测 显示对象的方法，hitTestPoint,检测是否与指定点相交，目前来说意义不大。 精确碰撞检测 hitTestPoint方法增加一个参数，true开启精确碰撞检测，消耗更多资源，是基于像素的检测而不是包围盒。 包围盒检测 文档中没有提到这个，但是指南中给出了，思路是利用两个包围盒，即利用egret.Rectangle确定两个矩形区域，然后利用Rectangle类中的方法inersects，rect1.intersects(rect2)来判断是否相交。 动画 对于动画，egret提供多种处理，如逐帧动画，或是tween库实现缓动动画 逐帧动画 素材制作 采用gif图片转换的方式。可以生成逐帧动画图片和逐帧动画数据，利用的工具是Texture Merger,导出最终文件包含两个一个是描述动画的配置文件.json,一个是图片纹理集。 素材引入 egretProperties.json配置文件需要增加game库，原因是这个动画帧类是来自game库的 default.res.json配置文件加入导入的json文件和纹理集图片。 创建逐帧动画 MovieClip中的MovieClipData是存储逐帧动画数据，而MovieClipDataFactory是用来存储MoiveClipData和Texture,存储数据和纹理的。 MovieClip功能的简化，使得只保留和动画相关的逻辑，而数据，纹理相关的操作与其分离。 MovieClip的使用： 先使用RES.getRes()获得资源（数据和纹理集） 然后new egret.MovieClipDataFactory(data,tex)得到一个movieClipDataFactory new egret.MovieClip(mcf.generateMovieClipData(“mcName(json文件中找到)”)) 即可创建一个MovieClip.包含json也包含纹理集，而json文件中可以得到不同帧资源名。刚创建的时候只能得到第一帧资源，所以mcf.spriteSheet.getTexture(“第一帧资源名”)，这个似乎不是很重要. 其它的例如停止动画，跳转动画，动画缓存的api都可以用到时再查阅了解。 还可以给帧图片添加事件。这个我没有试过不过应该很有意义。 tween缓动动画 egret.Tween.get定义缓动 第二个参数，可以加入变化事件处理函数的定义来实现逻辑的实时变化 如var obj = {x:0}; var funcChange = function():void{ console.log(this.x); } egret.Tween.get(obj,{onChange:funcChange,onChangeObj:obj}).to({x:600},1000,egret.Ease.backInOut); 缓动对象的控制有一些方法 主要有两种如call，用于缓动后的回调 如wait用于指定多个缓动连续设定中设置中间等待时间 应用解决针对以下需求： 制作英雄图demo与相关动作特效 探究实现遮罩与碰撞检测 缓动过程的事件处理 探究子弹类的处理 探究寻路算法 (待完成) 1 制作英雄图demo与相关动作特效 截取素材，利用工具制作gif,利用Texture Merger导出再应用到egret项目中。 在main.ts测试在createGameScene方法中 var data = RES.getRes(&quot;test_json&quot;); var txtr = RES.getRes(&quot;test_png&quot;); var mcFactory:egret.MovieClipDataFactory = new egret.MovieClipDataFactory( data, txtr ); var mc1:egret.MovieClip = new egret.MovieClip(mcFactory.generateMovieClipData(&quot;1&quot;)); this.addChild(mc1); this.stage.frameRate = 60; mc1.addEventListener(egret.Event.ENTER_FRAME,this.move,mc1); mc1.anchorOffsetX = 53; mc1.anchorOffsetY = 58.5; mc1.x = 53; mc1.y = 58.5; mc1.gotoAndPlay(1,-1); 首先我们关注这一部分：这是用来创建动画帧，然后加入到舞台的 var data = RES.getRes(&quot;test_json&quot;); var txtr = RES.getRes(&quot;test_png&quot;); var mcFactory:egret.MovieClipDataFactory = new egret.MovieClipDataFactory( data, txtr ); var mc1:egret.MovieClip = new egret.MovieClip(mcFactory.generateMovieClipData(&quot;1&quot;)); this.addChild(mc1); 在播放之前，我们写了监听，每一帧改变图片的坐标，使得图片运动起来，这样使得动画也可以运动起来，move方法等会解释。 mc1.addEventListener(egret.Event.ENTER_FRAME,this.move,mc1); 这里设置锚点为动画图片的一半宽一半高，因为没有anchorX和anchorY方法(这个可以直接设置相对比例0.5).关于锚点在了解后，如果我们想图片从原点开始需要设置x,y坐标为宽高的一半，因为是以锚点为基准进行定位了。 mc1.anchorOffsetX = 53; mc1.anchorOffsetY = 58.5; mc1.x = 53; mc1.y = 58.5; mc1.gotoAndPlay(1,-1); move方法，之所以设置锚点，是为了图片进行旋转，否则会出现bug，即旋转之后又x坐标减小，同时为了模拟碰撞，做了一个测试，即当检测到300,40的点时，改变角度，同时更改行动方式。这里就没有针对不同角度给出不同的动画了，对于一个小游戏可能过于繁琐，而是采用图片旋转的方式，不过看上去有点别扭。 private move(evt:egret.Event){ if(this.hitTestPoint(300,40)){ this.rotation = 90; this.y = this.y + 1; }else{ this.rotation = 0; this.x = this.x + 1; } } 2 碰撞检测 如果有碰撞检测的需求，可以结合上面提到的两个包围盒方法进行针对性解决. 由于可显示对象都是图片，有宽高，有x,y坐标，因此包围盒的方法还是有效的。 但是图片中人物的占空间和其它实际因素可能会影响，根据需求选择。 3 缓动过程的事件处理 如果是动画的事件处理，如对于死亡事件，我们可以直接stop动画，然后从父容器中remove，随后delete帧动画。 这样可以解决动画结束之前死亡的问题，至于何时攻击有效，可能得经过调试，也可以做的模糊一些。 如果是缓动过程需要有事件处理，如子弹的缓动过程碰到目标之前遇到其它敌方英雄，缓动提前结束，这是一个事件处理，这里可以直接获取tween对象，使用缓动结束方法，使用改方法的条件，可以采用碰撞检测的方式，即子弹与目标进行碰撞就终止缓动，可以把子弹当作一个点，或是矩形，这是后面具体处理方式的不同。 4 子弹的处理 方便的方式即是采用缓动，并且使用tween.to来进行子弹移动. 其实把子弹的移动速度提高，3中提到的子弹缓动过程的事件处理是不需要的，因为只要确定tween.to的目标几乎总能击中目标。","categories":[{"name":"Web前端","slug":"Web前端","permalink":"/categories/Web前端/"},{"name":"游戏","slug":"Web前端/游戏","permalink":"/categories/Web前端/游戏/"}],"tags":[{"name":"egret","slug":"egret","permalink":"/tags/egret/"}],"keywords":[{"name":"Web前端","slug":"Web前端","permalink":"/categories/Web前端/"},{"name":"游戏","slug":"Web前端/游戏","permalink":"/categories/Web前端/游戏/"}]},{"title":"webGL入门(一)","slug":"WebGL入门(一)","date":"2020-07-03T00:59:35.637Z","updated":"2020-07-16T02:33:29.271Z","comments":true,"path":"2020/07/03/WebGL入门(一)/","link":"","permalink":"/2020/07/03/WebGL入门(一)/","excerpt":"","text":"WebGL介绍产生背景 WebGL出现之前，浏览器想要实现3d效果必须借助浏览器插件，如Adobe的flash，微软的silverLight等等 WebGL 是一组基于 JavaScript 语言的图形规范，浏览器厂商按照这组规范进行实现，为 Web 开发者提供一套3D图形相关的 API 这套api，使得开发者能够使用javscript语言与gpu进行通信．而webGL的gpu部分也有对应的编程语言简称GLSL,GLSL程序即为运行在gpu上的着色器程序．着色器程序接受cpu传递过来的数据（webgl使用js），然后对数据进行流水线处理，就可以显示在屏幕上从而实现各种3d应用．工作方式 WebGL的工作方式与流水线相似．从得到数据到渲染到屏幕上，流水线按照既定的步骤从原料到加工，每一步的处理的原材料是上一步加工得到的结果，加工最终形成完整的产品．这种渲染方式我们称之为图形管线/渲染管线 WebGL的图元是点，线段，三角形三种图元，而对于其它的webGL程序中出现的图形甚至一些逼真的不规则模型，都是由gpu将点用三角形图元绘制，并且由三角形平面拼接而成得到的． 传递给gpu的顶点数据和变换矩阵数据，顶点经过转换之后的坐标是webGL接受的坐标，即gpu渲染管线对这些数据进行流水线作业．gpu渲染管线作用过程 首先进入顶点着色器阶段，利用 GPU 的并行计算优势对顶点逐个进行坐标变换。 然后进入图元装配阶段，将顶点按照图元类型组装成图形。 接下来来到光栅化阶段，光栅化阶段将图形用不包含颜色信息的像素填充。 在之后进入片元着色器阶段，该阶段为像素着色，并最终显示在屏幕上。 GLSL GLSL是OpenGL Shading Language缩写，即openGL的着色器语言 着色器语言指的是运行在gpu上的剪短程序，代替了gpu固定渲染管线的一部分，使得gpu渲染程序能够通过编程控制. GLSL控制gpu渲染管线的部分: 顶点着色器 片元着色器 开发者可通过编程控制gpu渲染管线的部分: js程序，传递顶点数据，法向量，纹理，颜色等等 顶点着色器 片元着色器 关于顶点信息的变换： 在js中进行，即通过js代码将通过变换矩阵转换好的顶点信息传递给gpu 在js中将变换矩阵传递给着色器程序，由顶点着色器程序实现对顶点信息的转换． 本篇文章是对WebGL的整体简介，是WebGL入门的第一篇文章，后续会对WebGL编程的学习进行完整的记录．","categories":[{"name":"Web前端","slug":"Web前端","permalink":"/categories/Web前端/"}],"tags":[{"name":"WebGL","slug":"WebGL","permalink":"/tags/WebGL/"}],"keywords":[{"name":"Web前端","slug":"Web前端","permalink":"/categories/Web前端/"}]},{"title":"flutter系列之dart事件循环","slug":"dart事件循环","date":"2020-07-01T14:23:29.026Z","updated":"2020-07-03T12:43:47.311Z","comments":true,"path":"2020/07/01/dart事件循环/","link":"","permalink":"/2020/07/01/dart事件循环/","excerpt":"上一篇介绍了dart基础．这一篇将讲述flutter代码的执行和运行的机制． Dart单线程类比js．js单线程关键点在于主线程，微任务与宏任务． 主线程－主业务逻辑 异步，网络I/O,本地文件I/O,采用事件驱动执行 dart中单线程执行，其中包含两个事件队列，一个是微任务事件队列，一个是事件队列(对应于js的宏任务) 微任务队列：scheduleMicrotask调度 事件队列: 包含外部事件，如I/O,Timer,绘制事件等等 事件循环过程对于js的事件循环之前有出过一篇文章，此处再贴一篇讲的很不错的js事件循环的文章，有助于对其加深理解．从一道题浅说JavaScript的事件循环而对于dart，刚才介绍了dart单线程相关的核心内容，在掌握了js的事件循环后，类比到dart上也十分容易． 1).执行main函数，产生微任务和事件任务队列2).判断是否存在微任务，有则执行，执行完后再判断是否还存在微任务，没则判断是否存在事件任务（即每当一个任务执行完成后，微任务会执行到微任务队列清空再去看事件队列是否有任务)3).如果有事件任务，执行完后再判断是否还有微任务，如果有先执行微任务．如24).在微任务和宏任务执行时，也会产生新的微任务和事件任务．","text":"上一篇介绍了dart基础．这一篇将讲述flutter代码的执行和运行的机制． Dart单线程类比js．js单线程关键点在于主线程，微任务与宏任务． 主线程－主业务逻辑 异步，网络I/O,本地文件I/O,采用事件驱动执行 dart中单线程执行，其中包含两个事件队列，一个是微任务事件队列，一个是事件队列(对应于js的宏任务) 微任务队列：scheduleMicrotask调度 事件队列: 包含外部事件，如I/O,Timer,绘制事件等等 事件循环过程对于js的事件循环之前有出过一篇文章，此处再贴一篇讲的很不错的js事件循环的文章，有助于对其加深理解．从一道题浅说JavaScript的事件循环而对于dart，刚才介绍了dart单线程相关的核心内容，在掌握了js的事件循环后，类比到dart上也十分容易． 1).执行main函数，产生微任务和事件任务队列2).判断是否存在微任务，有则执行，执行完后再判断是否还存在微任务，没则判断是否存在事件任务（即每当一个任务执行完成后，微任务会执行到微任务队列清空再去看事件队列是否有任务)3).如果有事件任务，执行完后再判断是否还有微任务，如果有先执行微任务．如24).在微任务和宏任务执行时，也会产生新的微任务和事件任务．来看两道常见的例题例1. import &#39;dart:async&#39;; void main() { print(&#39;flow start&#39;); // 执行打印开始 // 执行判断为事件任务，添加到事件任务队列 Timer.run((){ print(&#39;event&#39;); // 执行事件任务，打印标记 }); // 执行判断为微任务，添加到微任务队列 scheduleMicrotask((){ print(&#39;microtask&#39;); // 执行微任务，打印标记 }); print(&#39;flow end&#39;); // 打印结束标记 } 结果是 flow start flow end microtask event 分析过程：1).首先执行main函数中的代码，打印flow start2).Timer为事件任务，放入事件队列，scheduleMicrotask为微任务，放入微任务队列，同时向下执行代码打印flow end3).先从微任务队列中取出微任务执行，因此打印microtask4).微任务队列为空，则从事件任务队列中取出事件任务执行，打印event例2. import &#39;dart:async&#39;; void main() { print(&#39;flow start&#39;); // 执行打印开始 // 执行判断为事件任务，添加到事件任务队列 Timer.run((){ print(&#39;event&#39;); // 执行事件任务，打印事件任务记 // 执行判断为微任务，添加到微任务队列 scheduleMicrotask((){ print(&#39;microtask in event&#39;); // 执行微任务，打印微任务标记 }); }); // 执行判断为微任务，添加到微任务队列 scheduleMicrotask((){ print(&#39;microtask&#39;); // 执行微任务，打印微任务执行标记 // 执行判断为事件任务，添加到事件任务队列 Timer.run((){ print(&#39;event in microtask&#39;); // 执行事件任务，打印事件任务标记 }); }); print(&#39;flow end&#39;); // 打印结束标记 } 结果 flow start flow end microtask event microtask in event event in microtask 分析过程：1).main函数中代码先执行打印flow start2).Timer,为事件任务，放入事件任务队列．3).代码向下执行，scheduleMicrotask为微任务，放入微任务队列4).继续向下执行，打印flow end5).此时，微任务队列中有任务，因此执行scheduleMicrotask中代码，先print microtask,然后Timer放入事件任务队列6).微任务队列为空，因此去事件任务队列取出最先放入队列中的事件任务．打印event,向下遇到scheduleMicrotask，放入微任务队列．7).事件任务执行完毕后，由于微任务队列中有任务，所以执行微任务．因此先打印microtask in event．8).最后执行事件任务队列中的打印event in microtask 引发出的一个问题 dart在运行过程中可能被事件运行卡住 可想而知的是，当事件任务执行时，如果进行了密集计算，其中等待事件任务执行结束的时间就会增长． 而从事件循环．我们知道如果当前事件任务没有执行结束，是无法进行下一轮循环的．因此整个dart运行就会被卡住． 因此避免由于事件密集计算而导致较差的用户体验． 关于dart多线程内容，我们放在下一篇博客中介绍，届时我们会对dart运行原理大概有一个整体的掌握．然后就会进入flutter的学习之中．","categories":[{"name":"Web前端","slug":"Web前端","permalink":"/categories/Web前端/"}],"tags":[{"name":"dart","slug":"dart","permalink":"/tags/dart/"},{"name":"flutter","slug":"flutter","permalink":"/tags/flutter/"},{"name":"事件循环","slug":"事件循环","permalink":"/tags/事件循环/"}],"keywords":[{"name":"Web前端","slug":"Web前端","permalink":"/categories/Web前端/"}]},{"title":"flutter系列之dart基础","slug":"dart基础(一)","date":"2020-06-29T14:08:11.019Z","updated":"2020-07-29T13:18:17.312Z","comments":true,"path":"2020/06/29/dart基础(一)/","link":"","permalink":"/2020/06/29/dart基础(一)/","excerpt":"由于近期有学习flutter的兴趣，因此首先学习其所需的编程语言dart.并采用dart与js对比差异的方式来进行学习． 基础数据类型 Number和String与js使用基本一致 Symbol的区别 js中，Symbol是将基础数据类型转换为唯一标识符，核心应用是将复杂引用数据类型转换为对象数据类型的键名．具体可参考js中Symbol,map,set 在 Dart 中，Symbol 是不透明的动态字符串名称，用于反映库中的元数据。用 Symbol 可以获得或引用类的一个镜像，概念比较复杂，但其实和 JavaScript 的用法基本上是一致的。例如，下面代码首先 new 了一个 test 为 Map 数据类型，设置一个属性 #t（Symbol 类型），然后分别打印 test、test 的 #t、test 的 Symbol(“t”) 和 #t。 void main() { Map test = new Map(); test[#t] = &#39;symbol test&#39;; print(test); print(test[#t]); print(test[Symbol(&#39;t&#39;)]); print(#t); } 结果： flutter: {Symbol(&quot;t&quot;): symbol test} flutter: symbol test flutter: symbol test flutter: Symbol(&quot;t&quot;) #t与Symbol(“t”)结果一致，由此可见，dart中的symbol更像是一个反射概念，而在js中是创建唯一标识的概念．","text":"由于近期有学习flutter的兴趣，因此首先学习其所需的编程语言dart.并采用dart与js对比差异的方式来进行学习． 基础数据类型 Number和String与js使用基本一致 Symbol的区别 js中，Symbol是将基础数据类型转换为唯一标识符，核心应用是将复杂引用数据类型转换为对象数据类型的键名．具体可参考js中Symbol,map,set 在 Dart 中，Symbol 是不透明的动态字符串名称，用于反映库中的元数据。用 Symbol 可以获得或引用类的一个镜像，概念比较复杂，但其实和 JavaScript 的用法基本上是一致的。例如，下面代码首先 new 了一个 test 为 Map 数据类型，设置一个属性 #t（Symbol 类型），然后分别打印 test、test 的 #t、test 的 Symbol(“t”) 和 #t。 void main() { Map test = new Map(); test[#t] = &#39;symbol test&#39;; print(test); print(test[#t]); print(test[Symbol(&#39;t&#39;)]); print(#t); } 结果： flutter: {Symbol(&quot;t&quot;): symbol test} flutter: symbol test flutter: symbol test flutter: Symbol(&quot;t&quot;) #t与Symbol(“t”)结果一致，由此可见，dart中的symbol更像是一个反射概念，而在js中是创建唯一标识的概念． undefined和null dart与js不同，dart是静态脚本语言，所以如果没有定义一个变量无法通过编译，js是存在脚本在运行期间变量没定义的情况． 为了避免因为一个变量无法通过编译，dart中不采用undefined，而是使用null,dart中null是弱类型object的子类型，不是基础数据类型．而所有数据类型，被初始化后没有被赋值的话自动赋值为null类型．Map和List 与js中Array和Map基本一致，但在js中不是基本数据类型，属于引用数据类型．分类不同，在用法和类型上没有什么差异．弱类型-var,object及dynamic dart也存在弱类型，使用var,object,dynamic来声明，同时为了避免弱类型导致客户端Crash的异常，Dart对弱类型加强了检验． var声明，第一次赋值将数据类型绑定，如果再更改类型，会在dart编译前就报错． object声明相当于js中的var声明赋值，在编译期间，object会对数据调用做一定判断并且报错，声明与调用必须是对应的类型．如声明为String类型，调用length就会报错．由于数据可能来自接口层，所以减少使用以避免运行时报错导致客户端Crash的异常． dynamic也是动态数据类型，但数据类型调用异常时只会在运行时报错，不会在编译前和编译期间导致报错，所以这点很危险． 基础运算符 dart是强数据类型因此没有”===”运算符．同时有一些类型测试运算符和js中类型转换以及typeof相似．不加介绍．??运算符 t??’test’即t!=null?t:’test’级联操作 允许对同一对象或者函数进行一系列操作，依次调用方法如testObj.add(&#39;t&#39;) ...delete(&#39;a&#39;) ...show() 函数 明显区别就是dart由于是强数据类型，所以在声明函数的时候可以增加一个返回值类型． 类命名构造函数 支持多个构造函数，实例化可以有选择class People{ String face; People.nice(){ this.face = &#39;nice&#39;; } People.bad(){ this.face = &#39;bad&#39;; } } void main(List&lt;String&gt;args){ People niceOne = new People.nice(); print(niceOne.face); People badOone = new Poeple.bad(); print(badOne.face) } 结果不言而喻访问控制 需要设置私有属性，就在方法或者属性前添加’_’抽象类和泛型类 库与调用dart库管理 库管理资源pub.dev中找到需要的库．在dart配置文件pubspec.yaml中添加就可以使用该库，就像在js的package.json中添加声明一样，也有dependencies和dev_dependencies开发dart库 开发好的库发表在pub.dev就可以了，和npm管理一致．如何发布按照官网 pubspec就像package一样，lib下，核心是对应的库文件.dart，是包含一个dart类，所以可以将私有方法用_保护，其他的可以被引用的模块调用．自己开发的无须发布在pub.dev的实现逻辑，可以放在src下．调用dart库． import &#39;package:startup_namer/pages/homepage.dart&#39; 其中package表示协议，比http好，避免性能影响，然后是库名/项目名，lib下的一个文件夹，具体引入的库文件名 比相对路径的方式要好，建议采用package方式，保证项目代码一致性 其中本篇文章提到的关于js中引用数据类型，以及前端工程化包括webpack,npm script会在后续整理后出相关文章．","categories":[{"name":"Web前端","slug":"Web前端","permalink":"/categories/Web前端/"}],"tags":[{"name":"dart","slug":"dart","permalink":"/tags/dart/"},{"name":"flutter","slug":"flutter","permalink":"/tags/flutter/"}],"keywords":[{"name":"Web前端","slug":"Web前端","permalink":"/categories/Web前端/"}]},{"title":"事件循环EventLoop(一)","slug":"js基础复习之事件循环EventLoop(一)","date":"2020-06-02T15:15:42.000Z","updated":"2020-07-16T02:33:25.027Z","comments":true,"path":"2020/06/02/js基础复习之事件循环EventLoop(一)/","link":"","permalink":"/2020/06/02/js基础复习之事件循环EventLoop(一)/","excerpt":"","text":"运行时概念栈 函数调用形成若干帧组成栈堆 对于js，对象处于堆中(非结构化的内存区域)队列 js运行时，会包含一个待处理消息的消息队列，而每个消息会有对应回调函数来处理消息． 在EventLoop的某个时刻开始，运行时优先处理先进入队列中的消息，然后被处理后移除队列，作为参数来调用与之关联的函数，即为该函数创建一个栈帧．此处反映了消息队列与执行栈之间彼此隔离而又互相联系的关系． 函数处理会处理直至栈为空，然后事件循环会读取下一个信息(注意理解这一点，对于判断事件循环带来的程序块执行先后顺序问题有很大帮助)事件循环 while (queue.waitForMessage()) { queue.processNextMessage(); } 类似于如此调用 执行至完成 每个消息完整的执行后，执行其它消息* 它当一个函数在执行时，不会被抢占，同时只有在它运行结束之后才能运行其它代码，这与C语言不同，如如果函数在线程中运行，可以在任何地方被终止,然后在另一个线程中运行其它代码． 缺点在于当一个消息占用太多时间来处理时，web应用会无法处理与用户的交互，因此需要减少单独处理时间，或是分割处理多个子消息． 添加消息 事件发生并且有事件监听器绑定在该事件上时，会把一个消息添加到消息队列．无事件监听器，消息会消失 例如一个点击事件处理器的元素被点击，会像其它事件一样产生一个类似的消息． setTimeOut实际上就包含了两个参数，第一个参数是消息，所以第二个参数反应的延迟时间不一定是真实的，而是要看消息队列中有没有正在处理的消息，若有，则需要等待处理完毕，然后会将消息添加到消息队列． 如果队列无消息并且栈也为空，则这段延迟过后，会马上处理消息．永不阻塞 js事件循环模型使得与其他语言不同，它永不阻塞．处理I/O通常通过事件和回调来执行．所以当一个应用正等待一个 IndexedDB 查询返回或者一个 XHR 请求返回时，它仍然可以处理其它事情，比如用户输入。","categories":[{"name":"Web前端","slug":"Web前端","permalink":"/categories/Web前端/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"/tags/javascript/"}],"keywords":[{"name":"Web前端","slug":"Web前端","permalink":"/categories/Web前端/"}]},{"title":"javascript的内存管理","slug":"js基础复习之内存管理","date":"2020-05-31T06:47:24.000Z","updated":"2020-07-16T02:33:18.115Z","comments":true,"path":"2020/05/31/js基础复习之内存管理/","link":"","permalink":"/2020/05/31/js基础复习之内存管理/","excerpt":"","text":"内存生命周期 分配你所需要的内存 使用分配到的内存读写 不需要时将其释放\\归还 javascript的内存分配 值初始化 函数调用 使用值 对分配内存进行读取和写入的操作，读取和写入可能是写入一个变量或者一个对象的属性值，传递函数参数 不需要时释放 垃圾回收器跟踪内存分配和使用，当分配内存不使用时自动释放．近似过程，无法判定 垃圾回收 引用 在内存管理的environment中，一个对象如果有访问另一个对象的权限，就叫一个对象引用另一个对象．对象对它原型的引用(隐式引用)，对它属性的引用(显式引用)． 对象包括函数作用域(全局词法作用域) 引用计数垃圾收集 最初级的垃圾收集算法 对象是否不再需要-&gt;对象有没有被其他对象引用，如果为0引用，对象被垃圾回收机制回收 限制：循环引用 标记-清除算法 对象是否不再需要-&gt;对象是否可以获得 定期从root对象-&gt;root引用的对象-&gt;… 可以获得所有可获得的对象和收集所有不可获得的对象 有0引用的对象总是不可获得的，但反之不一定，如循环引用(函数内部) 函数调用返回之后，对象从全局作用域下无法获得，所以定期会被垃圾回收器回收到． 限制：无法从根对象查询到的对象 简化定义一定有限制","categories":[{"name":"Web前端","slug":"Web前端","permalink":"/categories/Web前端/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"/tags/javascript/"}],"keywords":[{"name":"Web前端","slug":"Web前端","permalink":"/categories/Web前端/"}]}]}