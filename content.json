{"meta":{"title":"青山入我怀","subtitle":null,"description":"尔入我梦来","author":"LiJiajun","url":""},"pages":[{"title":"about","date":"2018-12-12T14:14:36.000Z","updated":"2020-03-16T10:41:30.000Z","comments":false,"path":"about/index.html","permalink":"/about/index.html","excerpt":"","text":"[さくら荘のhojun] 与&nbsp; Mashiro&nbsp; （ 真（ま）白（しろ） ） 对话中... bot_ui_ini()","keywords":"关于"},{"title":"bangumi","date":"2019-02-10T13:32:48.000Z","updated":"2020-03-16T10:41:30.000Z","comments":false,"path":"bangumi/index.html","permalink":"/bangumi/index.html","excerpt":"","text":"","keywords":null},{"title":"client","date":"2018-12-20T15:13:35.000Z","updated":"2020-03-16T10:41:30.000Z","comments":false,"path":"client/index.html","permalink":"/client/index.html","excerpt":"","text":"直接下载 or 扫码下载：","keywords":"Android客户端"},{"title":"categories","date":"2020-07-03T01:45:35.000Z","updated":"2020-07-03T01:46:24.359Z","comments":true,"path":"categories/index.html","permalink":"/categories/index.html","excerpt":"","text":""},{"title":"donate","date":"2018-12-20T15:13:05.000Z","updated":"2020-03-16T10:41:30.000Z","comments":false,"path":"donate/index.html","permalink":"/donate/index.html","excerpt":"","text":"","keywords":"谢谢饲主了喵~"},{"title":"comment","date":"2018-12-20T15:13:48.000Z","updated":"2020-03-16T10:41:30.000Z","comments":true,"path":"comment/index.html","permalink":"/comment/index.html","excerpt":"","text":"念两句诗 叙别梦、扬州一觉。 【宋代】吴文英《夜游宫·人去西楼雁杳》","keywords":"留言板"},{"title":"links","date":"2018-12-19T15:11:06.000Z","updated":"2020-03-16T10:41:30.000Z","comments":true,"path":"links/index.html","permalink":"/links/index.html","excerpt":"","text":"","keywords":"友人帐"},{"title":"lab","date":"2019-01-05T13:47:59.000Z","updated":"2020-03-16T10:41:30.000Z","comments":false,"path":"lab/index.html","permalink":"/lab/index.html","excerpt":"","text":"sakura主题balabala","keywords":"Lab实验室"},{"title":"music","date":"2018-12-20T15:14:28.000Z","updated":"2020-07-03T11:47:24.478Z","comments":false,"path":"music/index.html","permalink":"/music/index.html","excerpt":"","text":"","keywords":"喜欢的音乐"},{"title":"rss","date":"2018-12-20T15:09:03.000Z","updated":"2020-03-16T10:41:30.000Z","comments":true,"path":"rss/index.html","permalink":"/rss/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-12-12T14:14:16.000Z","updated":"2020-03-16T10:41:30.000Z","comments":true,"path":"tags/index.html","permalink":"/tags/index.html","excerpt":"","text":""},{"title":"theme-sakura","date":"2019-01-04T14:53:25.000Z","updated":"2020-03-16T10:41:30.000Z","comments":false,"path":"theme-sakura/index.html","permalink":"/theme-sakura/index.html","excerpt":"","text":"Hexo主题Sakura修改自WordPress主题Sakura，感谢原作者Mashiro","keywords":"Hexo 主题 Sakura 🌸"},{"title":"video","date":"2018-12-20T15:14:38.000Z","updated":"2020-03-16T10:41:30.000Z","comments":false,"path":"video/index.html","permalink":"/video/index.html","excerpt":"","text":"var videos = [ { img: 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '放送时间: 2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' }, { img : 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' } ] .should-ellipsis{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:95%;}.should-ellipsis-full{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:100%;}.should-ellipsis i{position:absolute;right:24px;}.grey-text{color:#9e9e9e !important}.grey-text.text-darken-4{color:#212121 !important}html{line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}img{border-style:none}progress{display:inline-block;vertical-align:baseline}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}html{-webkit-box-sizing:border-box;box-sizing:border-box}*,*:before,*:after{-webkit-box-sizing:inherit;box-sizing:inherit}ul:not(.browser-default){padding-left:0;list-style-type:none}ul:not(.browser-default)>li{list-style-type:none}.card{-webkit-box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2);box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2)}.hoverable{-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s}.hoverable:hover{-webkit-box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19);box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19)}i{line-height:inherit}i.right{float:right;margin-left:15px}.bangumi .right{float:right !important}.material-icons{text-rendering:optimizeLegibility;-webkit-font-feature-settings:'liga';-moz-font-feature-settings:'liga';font-feature-settings:'liga'}.row{margin-left:auto;margin-right:auto;margin-bottom:20px}.row:after{content:\"\";display:table;clear:both}.row .col{float:left;-webkit-box-sizing:border-box;box-sizing:border-box;padding:0 .75rem;min-height:1px}.row .col.s12{width:100%;margin-left:auto;left:auto;right:auto}@media only screen and (min-width:601px){.row .col.m6{width:50%;margin-left:auto;left:auto;right:auto}}html{line-height:1.5;font-family:-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,Oxygen-Sans,Ubuntu,Cantarell,\"Helvetica Neue\",sans-serif;font-weight:normal;color:rgba(0,0,0,0.87)}@media only screen and (min-width:0){html{font-size:14px}}@media only screen and (min-width:992px){html{font-size:14.5px}}@media only screen and (min-width:1200px){html{font-size:15px}}.card{position:relative;margin:.5rem 0 1rem 0;background-color:#fff;-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s;border-radius:2px}.card .card-title{font-size:24px;font-weight:300}.card .card-title.activator{cursor:pointer}.card .card-image{position:relative}.card .card-image img{display:block;border-radius:2px 2px 0 0;position:relative;left:0;right:0;top:0;bottom:0;width:100%}.card .card-content{padding:24px;border-radius:0 0 2px 2px}.card .card-content p{margin:0}.card .card-content .card-title{display:block;line-height:32px;margin-bottom:8px}.card .card-content .card-title i{line-height:32px}.card .card-reveal{padding:24px;position:absolute;background-color:#fff;width:100%;overflow-y:auto;left:0;top:100%;height:100%;z-index:3;display:none}.card .card-reveal .card-title{cursor:pointer;display:block}.waves-effect{position:relative;cursor:pointer;display:inline-block;overflow:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;vertical-align:middle;z-index:1;-webkit-transition:.3s ease-out;transition:.3s ease-out}.waves-effect img{position:relative;z-index:-1}.waves-block{display:block}::-webkit-input-placeholder{color:#d1d1d1}::-moz-placeholder{color:#d1d1d1}:-ms-input-placeholder{color:#d1d1d1}::-ms-input-placeholder{color:#d1d1d1}[type=\"radio\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"radio\"]:not(:checked)+span{position:relative;padding-left:35px;cursor:pointer;display:inline-block;height:25px;line-height:25px;font-size:1rem;-webkit-transition:.28s ease;transition:.28s ease;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border-radius:50%}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border:2px solid #5a5a5a}[type=\"radio\"]:not(:checked)+span:after{-webkit-transform:scale(0);transform:scale(0)}[type=\"checkbox\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"checkbox\"]:not(:checked):disabled+span:not(.lever):before{border:none;background-color:rgba(0,0,0,0.42)}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):before{width:0;height:0;border:3px solid transparent;left:6px;top:10px;-webkit-transform:rotateZ(37deg);transform:rotateZ(37deg);-webkit-transform-origin:100% 100%;transform-origin:100% 100%}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):after{height:20px;width:20px;background-color:transparent;border:2px solid #5a5a5a;top:0px;z-index:0}input[type=checkbox]:not(:disabled) ~ .lever:active:before,input[type=checkbox]:not(:disabled).tabbed:focus ~ .lever::before{-webkit-transform:scale(2.4);transform:scale(2.4);background-color:rgba(0,0,0,0.08)}input[type=range].focused:focus:not(.active)::-webkit-slider-thumb{-webkit-box-shadow:0 0 0 10px rgba(38,166,154,0.26);box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-moz-range-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-ms-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)} 番组计划 这里将是永远的回忆 window.onload = function(){ videos.forEach(function(video, i){ $('#rootRow').append(` ${video.title} ${video.jp} ${video.status} ${video.title} ${video.jp} 放送时间: ${video.time} ${video.desc} ${video.status} `) }) }","keywords":"B站"}],"posts":[{"title":"webGL入门(一)","slug":"WebGL入门(一)","date":"2020-07-03T00:59:35.637Z","updated":"2020-07-03T11:37:48.942Z","comments":true,"path":"2020/07/03/WebGL入门(一)/","link":"","permalink":"/2020/07/03/WebGL入门(一)/","excerpt":"WebGL介绍产生背景 WebGL出现之前，浏览器想要实现3d效果必须借助浏览器插件，如Adobe的flash，微软的silverLight等等 WebGL 是一组基于 JavaScript 语言的图形规范，浏览器厂商按照这组规范进行实现，为 Web 开发者提供一套3D图形相关的 API 这套api，使得开发者能够使用javscript语言与gpu进行通信．而webGL的gpu部分也有对应的编程语言简称GLSL,GLSL程序即为运行在gpu上的着色器程序．着色器程序接受cpu传递过来的数据（webgl使用js），然后对数据进行流水线处理，就可以显示在屏幕上从而实现各种3d应用．工作方式 WebGL的工作方式与流水线相似．从得到数据到渲染到屏幕上，流水线按照既定的步骤从原料到加工，每一步的处理的原材料是上一步加工得到的结果，加工最终形成完整的产品．这种渲染方式我们称之为图形管线/渲染管线 WebGL的图元是点，线段，三角形三种图元，而对于其它的webGL程序中出现的图形甚至一些逼真的不规则模型，都是由gpu将点用三角形图元绘制，并且由三角形平面拼接而成得到的． 传递给gpu的顶点数据和变换矩阵数据，顶点经过转换之后的坐标是webGL接受的坐标，即gpu渲染管线对这些数据进行流水线作业．gpu渲染管线作用过程 首先进入顶点着色器阶段，利用 GPU 的并行计算优势对顶点逐个进行坐标变换。 然后进入图元装配阶段，将顶点按照图元类型组装成图形。 接下来来到光栅化阶段，光栅化阶段将图形用不包含颜色信息的像素填充。 在之后进入片元着色器阶段，该阶段为像素着色，并最终显示在屏幕上。 GLSL","text":"WebGL介绍产生背景 WebGL出现之前，浏览器想要实现3d效果必须借助浏览器插件，如Adobe的flash，微软的silverLight等等 WebGL 是一组基于 JavaScript 语言的图形规范，浏览器厂商按照这组规范进行实现，为 Web 开发者提供一套3D图形相关的 API 这套api，使得开发者能够使用javscript语言与gpu进行通信．而webGL的gpu部分也有对应的编程语言简称GLSL,GLSL程序即为运行在gpu上的着色器程序．着色器程序接受cpu传递过来的数据（webgl使用js），然后对数据进行流水线处理，就可以显示在屏幕上从而实现各种3d应用．工作方式 WebGL的工作方式与流水线相似．从得到数据到渲染到屏幕上，流水线按照既定的步骤从原料到加工，每一步的处理的原材料是上一步加工得到的结果，加工最终形成完整的产品．这种渲染方式我们称之为图形管线/渲染管线 WebGL的图元是点，线段，三角形三种图元，而对于其它的webGL程序中出现的图形甚至一些逼真的不规则模型，都是由gpu将点用三角形图元绘制，并且由三角形平面拼接而成得到的． 传递给gpu的顶点数据和变换矩阵数据，顶点经过转换之后的坐标是webGL接受的坐标，即gpu渲染管线对这些数据进行流水线作业．gpu渲染管线作用过程 首先进入顶点着色器阶段，利用 GPU 的并行计算优势对顶点逐个进行坐标变换。 然后进入图元装配阶段，将顶点按照图元类型组装成图形。 接下来来到光栅化阶段，光栅化阶段将图形用不包含颜色信息的像素填充。 在之后进入片元着色器阶段，该阶段为像素着色，并最终显示在屏幕上。 GLSL GLSL是OpenGL Shading Language缩写，即openGL的着色器语言 着色器语言指的是运行在gpu上的剪短程序，代替了gpu固定渲染管线的一部分，使得gpu渲染程序能够通过编程控制. GLSL控制gpu渲染管线的部分: 顶点着色器 片元着色器 开发者可通过编程控制gpu渲染管线的部分: js程序，传递顶点数据，法向量，纹理，颜色等等 顶点着色器 片元着色器 关于顶点信息的变换： 在js中进行，即通过js代码将通过变换矩阵转换好的顶点信息传递给gpu 在js中将变换矩阵传递给着色器程序，由顶点着色器程序实现对顶点信息的转换． 本篇文章是对WebGL的整体简介，是WebGL入门的第一篇文章，后续会对WebGL编程的学习进行完整的记录．","categories":[{"name":"Web前端","slug":"Web前端","permalink":"/categories/Web前端/"}],"tags":[{"name":"WebGL","slug":"WebGL","permalink":"/tags/WebGL/"}],"keywords":[{"name":"Web前端","slug":"Web前端","permalink":"/categories/Web前端/"}]},{"title":"flutter系列之dart事件循环","slug":"dart事件循环","date":"2020-07-01T14:23:29.026Z","updated":"2020-07-03T12:43:47.311Z","comments":true,"path":"2020/07/01/dart事件循环/","link":"","permalink":"/2020/07/01/dart事件循环/","excerpt":"上一篇介绍了dart基础．这一篇将讲述flutter代码的执行和运行的机制． Dart单线程类比js．js单线程关键点在于主线程，微任务与宏任务． 主线程－主业务逻辑 异步，网络I/O,本地文件I/O,采用事件驱动执行 dart中单线程执行，其中包含两个事件队列，一个是微任务事件队列，一个是事件队列(对应于js的宏任务) 微任务队列：scheduleMicrotask调度 事件队列: 包含外部事件，如I/O,Timer,绘制事件等等 事件循环过程对于js的事件循环之前有出过一篇文章，此处再贴一篇讲的很不错的js事件循环的文章，有助于对其加深理解．从一道题浅说JavaScript的事件循环而对于dart，刚才介绍了dart单线程相关的核心内容，在掌握了js的事件循环后，类比到dart上也十分容易． 1).执行main函数，产生微任务和事件任务队列2).判断是否存在微任务，有则执行，执行完后再判断是否还存在微任务，没则判断是否存在事件任务（即每当一个任务执行完成后，微任务会执行到微任务队列清空再去看事件队列是否有任务)3).如果有事件任务，执行完后再判断是否还有微任务，如果有先执行微任务．如24).在微任务和宏任务执行时，也会产生新的微任务和事件任务．","text":"上一篇介绍了dart基础．这一篇将讲述flutter代码的执行和运行的机制． Dart单线程类比js．js单线程关键点在于主线程，微任务与宏任务． 主线程－主业务逻辑 异步，网络I/O,本地文件I/O,采用事件驱动执行 dart中单线程执行，其中包含两个事件队列，一个是微任务事件队列，一个是事件队列(对应于js的宏任务) 微任务队列：scheduleMicrotask调度 事件队列: 包含外部事件，如I/O,Timer,绘制事件等等 事件循环过程对于js的事件循环之前有出过一篇文章，此处再贴一篇讲的很不错的js事件循环的文章，有助于对其加深理解．从一道题浅说JavaScript的事件循环而对于dart，刚才介绍了dart单线程相关的核心内容，在掌握了js的事件循环后，类比到dart上也十分容易． 1).执行main函数，产生微任务和事件任务队列2).判断是否存在微任务，有则执行，执行完后再判断是否还存在微任务，没则判断是否存在事件任务（即每当一个任务执行完成后，微任务会执行到微任务队列清空再去看事件队列是否有任务)3).如果有事件任务，执行完后再判断是否还有微任务，如果有先执行微任务．如24).在微任务和宏任务执行时，也会产生新的微任务和事件任务．来看两道常见的例题例1. import &#39;dart:async&#39;; void main() { print(&#39;flow start&#39;); // 执行打印开始 // 执行判断为事件任务，添加到事件任务队列 Timer.run((){ print(&#39;event&#39;); // 执行事件任务，打印标记 }); // 执行判断为微任务，添加到微任务队列 scheduleMicrotask((){ print(&#39;microtask&#39;); // 执行微任务，打印标记 }); print(&#39;flow end&#39;); // 打印结束标记 } 结果是 flow start flow end microtask event 分析过程：1).首先执行main函数中的代码，打印flow start2).Timer为事件任务，放入事件队列，scheduleMicrotask为微任务，放入微任务队列，同时向下执行代码打印flow end3).先从微任务队列中取出微任务执行，因此打印microtask4).微任务队列为空，则从事件任务队列中取出事件任务执行，打印event例2. import &#39;dart:async&#39;; void main() { print(&#39;flow start&#39;); // 执行打印开始 // 执行判断为事件任务，添加到事件任务队列 Timer.run((){ print(&#39;event&#39;); // 执行事件任务，打印事件任务记 // 执行判断为微任务，添加到微任务队列 scheduleMicrotask((){ print(&#39;microtask in event&#39;); // 执行微任务，打印微任务标记 }); }); // 执行判断为微任务，添加到微任务队列 scheduleMicrotask((){ print(&#39;microtask&#39;); // 执行微任务，打印微任务执行标记 // 执行判断为事件任务，添加到事件任务队列 Timer.run((){ print(&#39;event in microtask&#39;); // 执行事件任务，打印事件任务标记 }); }); print(&#39;flow end&#39;); // 打印结束标记 } 结果 flow start flow end microtask event microtask in event event in microtask 分析过程：1).main函数中代码先执行打印flow start2).Timer,为事件任务，放入事件任务队列．3).代码向下执行，scheduleMicrotask为微任务，放入微任务队列4).继续向下执行，打印flow end5).此时，微任务队列中有任务，因此执行scheduleMicrotask中代码，先print microtask,然后Timer放入事件任务队列6).微任务队列为空，因此去事件任务队列取出最先放入队列中的事件任务．打印event,向下遇到scheduleMicrotask，放入微任务队列．7).事件任务执行完毕后，由于微任务队列中有任务，所以执行微任务．因此先打印microtask in event．8).最后执行事件任务队列中的打印event in microtask 引发出的一个问题 dart在运行过程中可能被事件运行卡住 可想而知的是，当事件任务执行时，如果进行了密集计算，其中等待事件任务执行结束的时间就会增长． 而从事件循环．我们知道如果当前事件任务没有执行结束，是无法进行下一轮循环的．因此整个dart运行就会被卡住． 因此避免由于事件密集计算而导致较差的用户体验． 关于dart多线程内容，我们放在下一篇博客中介绍，届时我们会对dart运行原理大概有一个整体的掌握．然后就会进入flutter的学习之中．","categories":[{"name":"Web前端","slug":"Web前端","permalink":"/categories/Web前端/"}],"tags":[{"name":"dart","slug":"dart","permalink":"/tags/dart/"},{"name":"flutter","slug":"flutter","permalink":"/tags/flutter/"},{"name":"事件循环","slug":"事件循环","permalink":"/tags/事件循环/"}],"keywords":[{"name":"Web前端","slug":"Web前端","permalink":"/categories/Web前端/"}]},{"title":"flutter系列之dart基础","slug":"dart基础(一)","date":"2020-06-29T14:08:11.019Z","updated":"2020-07-03T11:37:55.950Z","comments":true,"path":"2020/06/29/dart基础(一)/","link":"","permalink":"/2020/06/29/dart基础(一)/","excerpt":"由于近期有学习flutter的兴趣，因此首先学习其所需的编程语言dart.并采用dart与js对比差异的方式来进行学习． 基础数据类型 Number和String与js使用基本一致 Symbol的区别 js中，Symbol是将基础数据类型转换为唯一标识符，核心应用是将复杂引用数据类型转换为对象数据类型的键名．具体可参考js中Symbol,map,set 在 Dart 中，Symbol 是不透明的动态字符串名称，用于反映库中的元数据。用 Symbol 可以获得或引用类的一个镜像，概念比较复杂，但其实和 JavaScript 的用法基本上是一致的。例如，下面代码首先 new 了一个 test 为 Map 数据类型，设置一个属性 #t（Symbol 类型），然后分别打印 test、test 的 #t、test 的 Symbol(“t”) 和 #t。 void main() { Map test = new Map(); test[#t] = &#39;symbol test&#39;; print(test); print(test[#t]); print(test[Symbol(&#39;t&#39;)]); print(#t); } 结果： flutter: {Symbol(&quot;t&quot;): symbol test} flutter: symbol test flutter: symbol test flutter: Symbol(&quot;t&quot;) #t与Symbol(“t”)结果一致，由此可见，dart中的symbol更像是一个反射概念，而在js中是创建唯一标识的概念．","text":"由于近期有学习flutter的兴趣，因此首先学习其所需的编程语言dart.并采用dart与js对比差异的方式来进行学习． 基础数据类型 Number和String与js使用基本一致 Symbol的区别 js中，Symbol是将基础数据类型转换为唯一标识符，核心应用是将复杂引用数据类型转换为对象数据类型的键名．具体可参考js中Symbol,map,set 在 Dart 中，Symbol 是不透明的动态字符串名称，用于反映库中的元数据。用 Symbol 可以获得或引用类的一个镜像，概念比较复杂，但其实和 JavaScript 的用法基本上是一致的。例如，下面代码首先 new 了一个 test 为 Map 数据类型，设置一个属性 #t（Symbol 类型），然后分别打印 test、test 的 #t、test 的 Symbol(“t”) 和 #t。 void main() { Map test = new Map(); test[#t] = &#39;symbol test&#39;; print(test); print(test[#t]); print(test[Symbol(&#39;t&#39;)]); print(#t); } 结果： flutter: {Symbol(&quot;t&quot;): symbol test} flutter: symbol test flutter: symbol test flutter: Symbol(&quot;t&quot;) #t与Symbol(“t”)结果一致，由此可见，dart中的symbol更像是一个反射概念，而在js中是创建唯一标识的概念． undefined和null dart与js不同，dart是静态脚本语言，所以如果没有定义一个变量无法通过编译，js是存在脚本在运行期间变量没定义的情况． 为了避免因为一个变量无法通过编译，dart中不采用undefined，而是使用null,dart中null是弱类型object的子类型，不是基础数据类型．而所有数据类型，被初始化后没有被赋值的话自动赋值为null类型．Map和List 与js中Array和Map基本一致，但在js中不是基本数据类型，属于引用数据类型．分类不同，在用法和类型上没有什么差异．弱类型-var,object及dynamic dart也存在弱类型，使用var,object,dynamic来声明，同时为了避免弱类型导致客户端Crash的异常，Dart对弱类型加强了检验． var声明，第一次赋值将数据类型绑定，如果再更改类型，会在dart编译前就报错． object声明相当于js中的var声明赋值，在编译期间，object会对数据调用做一定判断并且报错，声明与调用必须是对应的类型．如声明为String类型，调用length就会报错．由于数据可能来自接口层，所以减少使用以避免运行时报错导致客户端Crash的异常． dynamic也是动态数据类型，但数据类型调用异常时只会在运行时报错，不会在编译前和编译期间导致报错，所以这点很危险． 基础运算符 dart是强数据类型因此没有”===”运算符．同时有一些类型测试运算符和js中类型转换以及typeof相似．不加介绍．??运算符 t??’test’即t!=null?t:’test’级联操作 允许对同一对象或者函数进行一系列操作，依次调用方法如testObj.add(&#39;t&#39;) ...delete(&#39;a&#39;) ...show() 函数 明显区别就是dart由于是强数据类型，所以在声明函数的时候可以增加一个返回值类型． 类命名构造函数 支持多个构造函数，实例化可以有选择class People{ String face; People.nice(){ this.face = &#39;nice&#39;; } People.bad(){ this.face = &#39;bad&#39;; } } void main(List&lt;String&gt;args){ People niceOne = new People.nice(); print(niceOne.face); People badOone = new Poeple.bad(); print(badOne.face) } 结果不言而喻访问控制 需要设置私有属性，就在方法或者属性前添加’_’抽象类和泛型类 库与调用dart库管理 库管理资源pub.dev中找到需要的库．在dart配置文件pubspec.yaml中添加就可以使用该库，就像在js的package.json中添加声明一样，也有dependencies和dev_dependencies开发dart库 开发好的库发表在pub.dev就可以了，和npm管理一致．如何发布按照官网 pubspec就像package一样，lib下，核心是对应的库文件.dart，是包含一个dart类，所以可以将私有方法用_保护，其他的可以被引用的模块调用．自己开发的无须发布在pub.dev的实现逻辑，可以放在src下．调用dart库． import &#39;package:startup_namer/pages/homepage.dart&#39; 其中package表示协议，比http好，避免性能影响，然后是库名/项目名，lib下的一个文件夹，具体引入的库文件名 比相对路径的方式要好，建议采用package方式，保证项目代码一致性 其中本篇文章提到的关于js中引用数据类型，以及前端工程化包括webpack,npm script会在后续整理后出相关文章．","categories":[{"name":"Web前端","slug":"Web前端","permalink":"/categories/Web前端/"}],"tags":[{"name":"dart","slug":"dart","permalink":"/tags/dart/"},{"name":"flutter","slug":"flutter","permalink":"/tags/flutter/"}],"keywords":[{"name":"Web前端","slug":"Web前端","permalink":"/categories/Web前端/"}]},{"title":"事件循环EventLoop(一)","slug":"js基础复习之事件循环EventLoop(一)","date":"2020-06-02T15:15:42.000Z","updated":"2020-07-03T12:44:20.275Z","comments":true,"path":"2020/06/02/js基础复习之事件循环EventLoop(一)/","link":"","permalink":"/2020/06/02/js基础复习之事件循环EventLoop(一)/","excerpt":"运行时概念栈 函数调用形成若干帧组成栈堆 对于js，对象处于堆中(非结构化的内存区域)队列 js运行时，会包含一个待处理消息的消息队列，而每个消息会有对应回调函数来处理消息． 在EventLoop的某个时刻开始，运行时优先处理先进入队列中的消息，然后被处理后移除队列，作为参数来调用与之关联的函数，即为该函数创建一个栈帧．此处反映了消息队列与执行栈之间彼此隔离而又互相联系的关系． 函数处理会处理直至栈为空，然后事件循环会读取下一个信息(注意理解这一点，对于判断事件循环带来的程序块执行先后顺序问题有很大帮助)事件循环","text":"运行时概念栈 函数调用形成若干帧组成栈堆 对于js，对象处于堆中(非结构化的内存区域)队列 js运行时，会包含一个待处理消息的消息队列，而每个消息会有对应回调函数来处理消息． 在EventLoop的某个时刻开始，运行时优先处理先进入队列中的消息，然后被处理后移除队列，作为参数来调用与之关联的函数，即为该函数创建一个栈帧．此处反映了消息队列与执行栈之间彼此隔离而又互相联系的关系． 函数处理会处理直至栈为空，然后事件循环会读取下一个信息(注意理解这一点，对于判断事件循环带来的程序块执行先后顺序问题有很大帮助)事件循环 while (queue.waitForMessage()) { queue.processNextMessage(); } 类似于如此调用执行至完成 每个消息完整的执行后，执行其它消息* 它当一个函数在执行时，不会被抢占，同时只有在它运行结束之后才能运行其它代码，这与C语言不同，如如果函数在线程中运行，可以在任何地方被终止,然后在另一个线程中运行其它代码． 缺点在于当一个消息占用太多时间来处理时，web应用会无法处理与用户的交互，因此需要减少单独处理时间，或是分割处理多个子消息． 添加消息 事件发生并且有事件监听器绑定在该事件上时，会把一个消息添加到消息队列．无事件监听器，消息会消失 例如一个点击事件处理器的元素被点击，会像其它事件一样产生一个类似的消息． setTimeOut实际上就包含了两个参数，第一个参数是消息，所以第二个参数反应的延迟时间不一定是真实的，而是要看消息队列中有没有正在处理的消息，若有，则需要等待处理完毕，然后会将消息添加到消息队列． 如果队列无消息并且栈也为空，则这段延迟过后，会马上处理消息．永不阻塞 js事件循环模型使得与其他语言不同，它永不阻塞．处理I/O通常通过事件和回调来执行．所以当一个应用正等待一个 IndexedDB 查询返回或者一个 XHR 请求返回时，它仍然可以处理其它事情，比如用户输入。","categories":[{"name":"Web前端","slug":"Web前端","permalink":"/categories/Web前端/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"/tags/javascript/"}],"keywords":[{"name":"Web前端","slug":"Web前端","permalink":"/categories/Web前端/"}]},{"title":"javascript的内存管理","slug":"js基础复习之内存管理","date":"2020-05-31T06:47:24.000Z","updated":"2020-07-03T11:38:01.950Z","comments":true,"path":"2020/05/31/js基础复习之内存管理/","link":"","permalink":"/2020/05/31/js基础复习之内存管理/","excerpt":"内存生命周期 分配你所需要的内存 使用分配到的内存读写 不需要时将其释放\\归还 javascript的内存分配 值初始化 函数调用 使用值 对分配内存进行读取和写入的操作，读取和写入可能是写入一个变量或者一个对象的属性值，传递函数参数 不需要时释放 垃圾回收器跟踪内存分配和使用，当分配内存不使用时自动释放．近似过程，无法判定 垃圾回收 引用 在内存管理的environment中，一个对象如果有访问另一个对象的权限，就叫一个对象引用另一个对象．对象对它原型的引用(隐式引用)，对它属性的引用(显式引用)． 对象包括函数作用域(全局词法作用域)","text":"内存生命周期 分配你所需要的内存 使用分配到的内存读写 不需要时将其释放\\归还 javascript的内存分配 值初始化 函数调用 使用值 对分配内存进行读取和写入的操作，读取和写入可能是写入一个变量或者一个对象的属性值，传递函数参数 不需要时释放 垃圾回收器跟踪内存分配和使用，当分配内存不使用时自动释放．近似过程，无法判定 垃圾回收 引用 在内存管理的environment中，一个对象如果有访问另一个对象的权限，就叫一个对象引用另一个对象．对象对它原型的引用(隐式引用)，对它属性的引用(显式引用)． 对象包括函数作用域(全局词法作用域) 引用计数垃圾收集 最初级的垃圾收集算法 对象是否不再需要-&gt;对象有没有被其他对象引用，如果为0引用，对象被垃圾回收机制回收 限制：循环引用 标记-清除算法 对象是否不再需要-&gt;对象是否可以获得 定期从root对象-&gt;root引用的对象-&gt;… 可以获得所有可获得的对象和收集所有不可获得的对象 有0引用的对象总是不可获得的，但反之不一定，如循环引用(函数内部) 函数调用返回之后，对象从全局作用域下无法获得，所以定期会被垃圾回收器回收到． 限制：无法从根对象查询到的对象 简化定义一定有限制","categories":[{"name":"Web前端","slug":"Web前端","permalink":"/categories/Web前端/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"/tags/javascript/"}],"keywords":[{"name":"Web前端","slug":"Web前端","permalink":"/categories/Web前端/"}]}]}